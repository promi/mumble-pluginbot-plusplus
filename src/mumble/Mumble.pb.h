// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Mumble.proto

#ifndef PROTOBUF_Mumble_2eproto__INCLUDED
#define PROTOBUF_Mumble_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace MumbleProto
{

// Internal implementation detail -- do not call these.
  void  protobuf_AddDesc_Mumble_2eproto();
  void protobuf_AssignDesc_Mumble_2eproto();
  void protobuf_ShutdownFile_Mumble_2eproto();

  class Version;
  class UDPTunnel;
  class Authenticate;
  class Ping;
  class Reject;
  class ServerSync;
  class ChannelRemove;
  class ChannelState;
  class UserRemove;
  class UserState;
  class BanList;
  class BanList_BanEntry;
  class TextMessage;
  class PermissionDenied;
  class ACL;
  class ACL_ChanGroup;
  class ACL_ChanACL;
  class QueryUsers;
  class CryptSetup;
  class ContextActionModify;
  class ContextAction;
  class UserList;
  class UserList_User;
  class VoiceTarget;
  class VoiceTarget_Target;
  class PermissionQuery;
  class CodecVersion;
  class UserStats;
  class UserStats_Stats;
  class RequestBlob;
  class ServerConfig;
  class SuggestConfig;

  enum Reject_RejectType
  {
    Reject_RejectType_None = 0,
    Reject_RejectType_WrongVersion = 1,
    Reject_RejectType_InvalidUsername = 2,
    Reject_RejectType_WrongUserPW = 3,
    Reject_RejectType_WrongServerPW = 4,
    Reject_RejectType_UsernameInUse = 5,
    Reject_RejectType_ServerFull = 6,
    Reject_RejectType_NoCertificate = 7,
    Reject_RejectType_AuthenticatorFail = 8
  };
  bool Reject_RejectType_IsValid(int value);
  const Reject_RejectType Reject_RejectType_RejectType_MIN =
    Reject_RejectType_None;
  const Reject_RejectType Reject_RejectType_RejectType_MAX =
    Reject_RejectType_AuthenticatorFail;
  const int Reject_RejectType_RejectType_ARRAYSIZE =
    Reject_RejectType_RejectType_MAX + 1;

  const ::google::protobuf::EnumDescriptor* Reject_RejectType_descriptor();
  inline const ::std::string& Reject_RejectType_Name(Reject_RejectType value)
  {
    return ::google::protobuf::internal::NameOfEnum(
             Reject_RejectType_descriptor(), value);
  }
  inline bool Reject_RejectType_Parse(
    const ::std::string& name, Reject_RejectType* value)
  {
    return ::google::protobuf::internal::ParseNamedEnum<Reject_RejectType>(
             Reject_RejectType_descriptor(), name, value);
  }
  enum PermissionDenied_DenyType
  {
    PermissionDenied_DenyType_Text = 0,
    PermissionDenied_DenyType_Permission = 1,
    PermissionDenied_DenyType_SuperUser = 2,
    PermissionDenied_DenyType_ChannelName = 3,
    PermissionDenied_DenyType_TextTooLong = 4,
    PermissionDenied_DenyType_H9K = 5,
    PermissionDenied_DenyType_TemporaryChannel = 6,
    PermissionDenied_DenyType_MissingCertificate = 7,
    PermissionDenied_DenyType_UserName = 8,
    PermissionDenied_DenyType_ChannelFull = 9,
    PermissionDenied_DenyType_NestingLimit = 10
  };
  bool PermissionDenied_DenyType_IsValid(int value);
  const PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MIN =
    PermissionDenied_DenyType_Text;
  const PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MAX =
    PermissionDenied_DenyType_NestingLimit;
  const int PermissionDenied_DenyType_DenyType_ARRAYSIZE =
    PermissionDenied_DenyType_DenyType_MAX + 1;

  const ::google::protobuf::EnumDescriptor*
  PermissionDenied_DenyType_descriptor();
  inline const ::std::string& PermissionDenied_DenyType_Name(
    PermissionDenied_DenyType value)
  {
    return ::google::protobuf::internal::NameOfEnum(
             PermissionDenied_DenyType_descriptor(), value);
  }
  inline bool PermissionDenied_DenyType_Parse(
    const ::std::string& name, PermissionDenied_DenyType* value)
  {
    return ::google::protobuf::internal::ParseNamedEnum<PermissionDenied_DenyType>(
             PermissionDenied_DenyType_descriptor(), name, value);
  }
  enum ContextActionModify_Context
  {
    ContextActionModify_Context_Server = 1,
    ContextActionModify_Context_Channel = 2,
    ContextActionModify_Context_User = 4
  };
  bool ContextActionModify_Context_IsValid(int value);
  const ContextActionModify_Context ContextActionModify_Context_Context_MIN =
    ContextActionModify_Context_Server;
  const ContextActionModify_Context ContextActionModify_Context_Context_MAX =
    ContextActionModify_Context_User;
  const int ContextActionModify_Context_Context_ARRAYSIZE =
    ContextActionModify_Context_Context_MAX + 1;

  const ::google::protobuf::EnumDescriptor*
  ContextActionModify_Context_descriptor();
  inline const ::std::string& ContextActionModify_Context_Name(
    ContextActionModify_Context value)
  {
    return ::google::protobuf::internal::NameOfEnum(
             ContextActionModify_Context_descriptor(), value);
  }
  inline bool ContextActionModify_Context_Parse(
    const ::std::string& name, ContextActionModify_Context* value)
  {
    return ::google::protobuf::internal::ParseNamedEnum<ContextActionModify_Context>
           (
             ContextActionModify_Context_descriptor(), name, value);
  }
  enum ContextActionModify_Operation
  {
    ContextActionModify_Operation_Add = 0,
    ContextActionModify_Operation_Remove = 1
  };
  bool ContextActionModify_Operation_IsValid(int value);
  const ContextActionModify_Operation ContextActionModify_Operation_Operation_MIN
    = ContextActionModify_Operation_Add;
  const ContextActionModify_Operation ContextActionModify_Operation_Operation_MAX
    = ContextActionModify_Operation_Remove;
  const int ContextActionModify_Operation_Operation_ARRAYSIZE =
    ContextActionModify_Operation_Operation_MAX + 1;

  const ::google::protobuf::EnumDescriptor*
  ContextActionModify_Operation_descriptor();
  inline const ::std::string& ContextActionModify_Operation_Name(
    ContextActionModify_Operation value)
  {
    return ::google::protobuf::internal::NameOfEnum(
             ContextActionModify_Operation_descriptor(), value);
  }
  inline bool ContextActionModify_Operation_Parse(
    const ::std::string& name, ContextActionModify_Operation* value)
  {
    return ::google::protobuf::internal::ParseNamedEnum<ContextActionModify_Operation>
           (
             ContextActionModify_Operation_descriptor(), name, value);
  }
// ===================================================================

  class Version : public ::google::protobuf::Message
  {
  public:
    Version();
    virtual ~Version();

    Version(const Version& from);

    inline Version& operator=(const Version& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const Version& default_instance();

    void Swap(Version* other);

    // implements Message ----------------------------------------------

    Version* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const Version& from);
    void MergeFrom(const Version& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 version = 1;
    inline bool has_version() const;
    inline void clear_version();
    static const int kVersionFieldNumber = 1;
    inline ::google::protobuf::uint32 version() const;
    inline void set_version(::google::protobuf::uint32 value);

    // optional string release = 2;
    inline bool has_release() const;
    inline void clear_release();
    static const int kReleaseFieldNumber = 2;
    inline const ::std::string& release() const;
    inline void set_release(const ::std::string& value);
    inline void set_release(const char* value);
    inline void set_release(const char* value, size_t size);
    inline ::std::string* mutable_release();
    inline ::std::string* release_release();
    inline void set_allocated_release(::std::string* release);

    // optional string os = 3;
    inline bool has_os() const;
    inline void clear_os();
    static const int kOsFieldNumber = 3;
    inline const ::std::string& os() const;
    inline void set_os(const ::std::string& value);
    inline void set_os(const char* value);
    inline void set_os(const char* value, size_t size);
    inline ::std::string* mutable_os();
    inline ::std::string* release_os();
    inline void set_allocated_os(::std::string* os);

    // optional string os_version = 4;
    inline bool has_os_version() const;
    inline void clear_os_version();
    static const int kOsVersionFieldNumber = 4;
    inline const ::std::string& os_version() const;
    inline void set_os_version(const ::std::string& value);
    inline void set_os_version(const char* value);
    inline void set_os_version(const char* value, size_t size);
    inline ::std::string* mutable_os_version();
    inline ::std::string* release_os_version();
    inline void set_allocated_os_version(::std::string* os_version);

    // @@protoc_insertion_point(class_scope:MumbleProto.Version)
  private:
    inline void set_has_version();
    inline void clear_has_version();
    inline void set_has_release();
    inline void clear_has_release();
    inline void set_has_os();
    inline void clear_has_os();
    inline void set_has_os_version();
    inline void clear_has_os_version();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* release_;
    ::std::string* os_;
    ::std::string* os_version_;
    ::google::protobuf::uint32 version_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static Version* default_instance_;
  };
// -------------------------------------------------------------------

  class UDPTunnel : public ::google::protobuf::Message
  {
  public:
    UDPTunnel();
    virtual ~UDPTunnel();

    UDPTunnel(const UDPTunnel& from);

    inline UDPTunnel& operator=(const UDPTunnel& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const UDPTunnel& default_instance();

    void Swap(UDPTunnel* other);

    // implements Message ----------------------------------------------

    UDPTunnel* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const UDPTunnel& from);
    void MergeFrom(const UDPTunnel& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required bytes packet = 1;
    inline bool has_packet() const;
    inline void clear_packet();
    static const int kPacketFieldNumber = 1;
    inline const ::std::string& packet() const;
    inline void set_packet(const ::std::string& value);
    inline void set_packet(const char* value);
    inline void set_packet(const void* value, size_t size);
    inline ::std::string* mutable_packet();
    inline ::std::string* release_packet();
    inline void set_allocated_packet(::std::string* packet);

    // @@protoc_insertion_point(class_scope:MumbleProto.UDPTunnel)
  private:
    inline void set_has_packet();
    inline void clear_has_packet();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* packet_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static UDPTunnel* default_instance_;
  };
// -------------------------------------------------------------------

  class Authenticate : public ::google::protobuf::Message
  {
  public:
    Authenticate();
    virtual ~Authenticate();

    Authenticate(const Authenticate& from);

    inline Authenticate& operator=(const Authenticate& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const Authenticate& default_instance();

    void Swap(Authenticate* other);

    // implements Message ----------------------------------------------

    Authenticate* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const Authenticate& from);
    void MergeFrom(const Authenticate& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string username = 1;
    inline bool has_username() const;
    inline void clear_username();
    static const int kUsernameFieldNumber = 1;
    inline const ::std::string& username() const;
    inline void set_username(const ::std::string& value);
    inline void set_username(const char* value);
    inline void set_username(const char* value, size_t size);
    inline ::std::string* mutable_username();
    inline ::std::string* release_username();
    inline void set_allocated_username(::std::string* username);

    // optional string password = 2;
    inline bool has_password() const;
    inline void clear_password();
    static const int kPasswordFieldNumber = 2;
    inline const ::std::string& password() const;
    inline void set_password(const ::std::string& value);
    inline void set_password(const char* value);
    inline void set_password(const char* value, size_t size);
    inline ::std::string* mutable_password();
    inline ::std::string* release_password();
    inline void set_allocated_password(::std::string* password);

    // repeated string tokens = 3;
    inline int tokens_size() const;
    inline void clear_tokens();
    static const int kTokensFieldNumber = 3;
    inline const ::std::string& tokens(int index) const;
    inline ::std::string* mutable_tokens(int index);
    inline void set_tokens(int index, const ::std::string& value);
    inline void set_tokens(int index, const char* value);
    inline void set_tokens(int index, const char* value, size_t size);
    inline ::std::string* add_tokens();
    inline void add_tokens(const ::std::string& value);
    inline void add_tokens(const char* value);
    inline void add_tokens(const char* value, size_t size);
    inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tokens()
    const;
    inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tokens();

    // repeated int32 celt_versions = 4;
    inline int celt_versions_size() const;
    inline void clear_celt_versions();
    static const int kCeltVersionsFieldNumber = 4;
    inline ::google::protobuf::int32 celt_versions(int index) const;
    inline void set_celt_versions(int index, ::google::protobuf::int32 value);
    inline void add_celt_versions(::google::protobuf::int32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
    celt_versions() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
    mutable_celt_versions();

    // optional bool opus = 5 [default = false];
    inline bool has_opus() const;
    inline void clear_opus();
    static const int kOpusFieldNumber = 5;
    inline bool opus() const;
    inline void set_opus(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.Authenticate)
  private:
    inline void set_has_username();
    inline void clear_has_username();
    inline void set_has_password();
    inline void clear_has_password();
    inline void set_has_opus();
    inline void clear_has_opus();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* username_;
    ::std::string* password_;
    ::google::protobuf::RepeatedPtrField< ::std::string> tokens_;
    ::google::protobuf::RepeatedField< ::google::protobuf::int32 > celt_versions_;
    bool opus_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static Authenticate* default_instance_;
  };
// -------------------------------------------------------------------

  class Ping : public ::google::protobuf::Message
  {
  public:
    Ping();
    virtual ~Ping();

    Ping(const Ping& from);

    inline Ping& operator=(const Ping& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const Ping& default_instance();

    void Swap(Ping* other);

    // implements Message ----------------------------------------------

    Ping* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const Ping& from);
    void MergeFrom(const Ping& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint64 timestamp = 1;
    inline bool has_timestamp() const;
    inline void clear_timestamp();
    static const int kTimestampFieldNumber = 1;
    inline ::google::protobuf::uint64 timestamp() const;
    inline void set_timestamp(::google::protobuf::uint64 value);

    // optional uint32 good = 2;
    inline bool has_good() const;
    inline void clear_good();
    static const int kGoodFieldNumber = 2;
    inline ::google::protobuf::uint32 good() const;
    inline void set_good(::google::protobuf::uint32 value);

    // optional uint32 late = 3;
    inline bool has_late() const;
    inline void clear_late();
    static const int kLateFieldNumber = 3;
    inline ::google::protobuf::uint32 late() const;
    inline void set_late(::google::protobuf::uint32 value);

    // optional uint32 lost = 4;
    inline bool has_lost() const;
    inline void clear_lost();
    static const int kLostFieldNumber = 4;
    inline ::google::protobuf::uint32 lost() const;
    inline void set_lost(::google::protobuf::uint32 value);

    // optional uint32 resync = 5;
    inline bool has_resync() const;
    inline void clear_resync();
    static const int kResyncFieldNumber = 5;
    inline ::google::protobuf::uint32 resync() const;
    inline void set_resync(::google::protobuf::uint32 value);

    // optional uint32 udp_packets = 6;
    inline bool has_udp_packets() const;
    inline void clear_udp_packets();
    static const int kUdpPacketsFieldNumber = 6;
    inline ::google::protobuf::uint32 udp_packets() const;
    inline void set_udp_packets(::google::protobuf::uint32 value);

    // optional uint32 tcp_packets = 7;
    inline bool has_tcp_packets() const;
    inline void clear_tcp_packets();
    static const int kTcpPacketsFieldNumber = 7;
    inline ::google::protobuf::uint32 tcp_packets() const;
    inline void set_tcp_packets(::google::protobuf::uint32 value);

    // optional float udp_ping_avg = 8;
    inline bool has_udp_ping_avg() const;
    inline void clear_udp_ping_avg();
    static const int kUdpPingAvgFieldNumber = 8;
    inline float udp_ping_avg() const;
    inline void set_udp_ping_avg(float value);

    // optional float udp_ping_var = 9;
    inline bool has_udp_ping_var() const;
    inline void clear_udp_ping_var();
    static const int kUdpPingVarFieldNumber = 9;
    inline float udp_ping_var() const;
    inline void set_udp_ping_var(float value);

    // optional float tcp_ping_avg = 10;
    inline bool has_tcp_ping_avg() const;
    inline void clear_tcp_ping_avg();
    static const int kTcpPingAvgFieldNumber = 10;
    inline float tcp_ping_avg() const;
    inline void set_tcp_ping_avg(float value);

    // optional float tcp_ping_var = 11;
    inline bool has_tcp_ping_var() const;
    inline void clear_tcp_ping_var();
    static const int kTcpPingVarFieldNumber = 11;
    inline float tcp_ping_var() const;
    inline void set_tcp_ping_var(float value);

    // @@protoc_insertion_point(class_scope:MumbleProto.Ping)
  private:
    inline void set_has_timestamp();
    inline void clear_has_timestamp();
    inline void set_has_good();
    inline void clear_has_good();
    inline void set_has_late();
    inline void clear_has_late();
    inline void set_has_lost();
    inline void clear_has_lost();
    inline void set_has_resync();
    inline void clear_has_resync();
    inline void set_has_udp_packets();
    inline void clear_has_udp_packets();
    inline void set_has_tcp_packets();
    inline void clear_has_tcp_packets();
    inline void set_has_udp_ping_avg();
    inline void clear_has_udp_ping_avg();
    inline void set_has_udp_ping_var();
    inline void clear_has_udp_ping_var();
    inline void set_has_tcp_ping_avg();
    inline void clear_has_tcp_ping_avg();
    inline void set_has_tcp_ping_var();
    inline void clear_has_tcp_ping_var();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint64 timestamp_;
    ::google::protobuf::uint32 good_;
    ::google::protobuf::uint32 late_;
    ::google::protobuf::uint32 lost_;
    ::google::protobuf::uint32 resync_;
    ::google::protobuf::uint32 udp_packets_;
    ::google::protobuf::uint32 tcp_packets_;
    float udp_ping_avg_;
    float udp_ping_var_;
    float tcp_ping_avg_;
    float tcp_ping_var_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static Ping* default_instance_;
  };
// -------------------------------------------------------------------

  class Reject : public ::google::protobuf::Message
  {
  public:
    Reject();
    virtual ~Reject();

    Reject(const Reject& from);

    inline Reject& operator=(const Reject& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const Reject& default_instance();

    void Swap(Reject* other);

    // implements Message ----------------------------------------------

    Reject* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const Reject& from);
    void MergeFrom(const Reject& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    typedef Reject_RejectType RejectType;
    static const RejectType None = Reject_RejectType_None;
    static const RejectType WrongVersion = Reject_RejectType_WrongVersion;
    static const RejectType InvalidUsername = Reject_RejectType_InvalidUsername;
    static const RejectType WrongUserPW = Reject_RejectType_WrongUserPW;
    static const RejectType WrongServerPW = Reject_RejectType_WrongServerPW;
    static const RejectType UsernameInUse = Reject_RejectType_UsernameInUse;
    static const RejectType ServerFull = Reject_RejectType_ServerFull;
    static const RejectType NoCertificate = Reject_RejectType_NoCertificate;
    static const RejectType AuthenticatorFail = Reject_RejectType_AuthenticatorFail;
    static inline bool RejectType_IsValid(int value)
    {
      return Reject_RejectType_IsValid(value);
    }
    static const RejectType RejectType_MIN =
      Reject_RejectType_RejectType_MIN;
    static const RejectType RejectType_MAX =
      Reject_RejectType_RejectType_MAX;
    static const int RejectType_ARRAYSIZE =
      Reject_RejectType_RejectType_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor*
    RejectType_descriptor()
    {
      return Reject_RejectType_descriptor();
    }
    static inline const ::std::string& RejectType_Name(RejectType value)
    {
      return Reject_RejectType_Name(value);
    }
    static inline bool RejectType_Parse(const ::std::string& name,
                                        RejectType* value)
    {
      return Reject_RejectType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // optional .MumbleProto.Reject.RejectType type = 1;
    inline bool has_type() const;
    inline void clear_type();
    static const int kTypeFieldNumber = 1;
    inline ::MumbleProto::Reject_RejectType type() const;
    inline void set_type(::MumbleProto::Reject_RejectType value);

    // optional string reason = 2;
    inline bool has_reason() const;
    inline void clear_reason();
    static const int kReasonFieldNumber = 2;
    inline const ::std::string& reason() const;
    inline void set_reason(const ::std::string& value);
    inline void set_reason(const char* value);
    inline void set_reason(const char* value, size_t size);
    inline ::std::string* mutable_reason();
    inline ::std::string* release_reason();
    inline void set_allocated_reason(::std::string* reason);

    // @@protoc_insertion_point(class_scope:MumbleProto.Reject)
  private:
    inline void set_has_type();
    inline void clear_has_type();
    inline void set_has_reason();
    inline void clear_has_reason();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* reason_;
    int type_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static Reject* default_instance_;
  };
// -------------------------------------------------------------------

  class ServerSync : public ::google::protobuf::Message
  {
  public:
    ServerSync();
    virtual ~ServerSync();

    ServerSync(const ServerSync& from);

    inline ServerSync& operator=(const ServerSync& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ServerSync& default_instance();

    void Swap(ServerSync* other);

    // implements Message ----------------------------------------------

    ServerSync* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ServerSync& from);
    void MergeFrom(const ServerSync& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 session = 1;
    inline bool has_session() const;
    inline void clear_session();
    static const int kSessionFieldNumber = 1;
    inline ::google::protobuf::uint32 session() const;
    inline void set_session(::google::protobuf::uint32 value);

    // optional uint32 max_bandwidth = 2;
    inline bool has_max_bandwidth() const;
    inline void clear_max_bandwidth();
    static const int kMaxBandwidthFieldNumber = 2;
    inline ::google::protobuf::uint32 max_bandwidth() const;
    inline void set_max_bandwidth(::google::protobuf::uint32 value);

    // optional string welcome_text = 3;
    inline bool has_welcome_text() const;
    inline void clear_welcome_text();
    static const int kWelcomeTextFieldNumber = 3;
    inline const ::std::string& welcome_text() const;
    inline void set_welcome_text(const ::std::string& value);
    inline void set_welcome_text(const char* value);
    inline void set_welcome_text(const char* value, size_t size);
    inline ::std::string* mutable_welcome_text();
    inline ::std::string* release_welcome_text();
    inline void set_allocated_welcome_text(::std::string* welcome_text);

    // optional uint64 permissions = 4;
    inline bool has_permissions() const;
    inline void clear_permissions();
    static const int kPermissionsFieldNumber = 4;
    inline ::google::protobuf::uint64 permissions() const;
    inline void set_permissions(::google::protobuf::uint64 value);

    // @@protoc_insertion_point(class_scope:MumbleProto.ServerSync)
  private:
    inline void set_has_session();
    inline void clear_has_session();
    inline void set_has_max_bandwidth();
    inline void clear_has_max_bandwidth();
    inline void set_has_welcome_text();
    inline void clear_has_welcome_text();
    inline void set_has_permissions();
    inline void clear_has_permissions();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 session_;
    ::google::protobuf::uint32 max_bandwidth_;
    ::std::string* welcome_text_;
    ::google::protobuf::uint64 permissions_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static ServerSync* default_instance_;
  };
// -------------------------------------------------------------------

  class ChannelRemove : public ::google::protobuf::Message
  {
  public:
    ChannelRemove();
    virtual ~ChannelRemove();

    ChannelRemove(const ChannelRemove& from);

    inline ChannelRemove& operator=(const ChannelRemove& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ChannelRemove& default_instance();

    void Swap(ChannelRemove* other);

    // implements Message ----------------------------------------------

    ChannelRemove* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ChannelRemove& from);
    void MergeFrom(const ChannelRemove& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required uint32 channel_id = 1;
    inline bool has_channel_id() const;
    inline void clear_channel_id();
    static const int kChannelIdFieldNumber = 1;
    inline ::google::protobuf::uint32 channel_id() const;
    inline void set_channel_id(::google::protobuf::uint32 value);

    // @@protoc_insertion_point(class_scope:MumbleProto.ChannelRemove)
  private:
    inline void set_has_channel_id();
    inline void clear_has_channel_id();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 channel_id_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static ChannelRemove* default_instance_;
  };
// -------------------------------------------------------------------

  class ChannelState : public ::google::protobuf::Message
  {
  public:
    ChannelState();
    virtual ~ChannelState();

    ChannelState(const ChannelState& from);

    inline ChannelState& operator=(const ChannelState& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ChannelState& default_instance();

    void Swap(ChannelState* other);

    // implements Message ----------------------------------------------

    ChannelState* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ChannelState& from);
    void MergeFrom(const ChannelState& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 channel_id = 1;
    inline bool has_channel_id() const;
    inline void clear_channel_id();
    static const int kChannelIdFieldNumber = 1;
    inline ::google::protobuf::uint32 channel_id() const;
    inline void set_channel_id(::google::protobuf::uint32 value);

    // optional uint32 parent = 2;
    inline bool has_parent() const;
    inline void clear_parent();
    static const int kParentFieldNumber = 2;
    inline ::google::protobuf::uint32 parent() const;
    inline void set_parent(::google::protobuf::uint32 value);

    // optional string name = 3;
    inline bool has_name() const;
    inline void clear_name();
    static const int kNameFieldNumber = 3;
    inline const ::std::string& name() const;
    inline void set_name(const ::std::string& value);
    inline void set_name(const char* value);
    inline void set_name(const char* value, size_t size);
    inline ::std::string* mutable_name();
    inline ::std::string* release_name();
    inline void set_allocated_name(::std::string* name);

    // repeated uint32 links = 4;
    inline int links_size() const;
    inline void clear_links();
    static const int kLinksFieldNumber = 4;
    inline ::google::protobuf::uint32 links(int index) const;
    inline void set_links(int index, ::google::protobuf::uint32 value);
    inline void add_links(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    links() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_links();

    // optional string description = 5;
    inline bool has_description() const;
    inline void clear_description();
    static const int kDescriptionFieldNumber = 5;
    inline const ::std::string& description() const;
    inline void set_description(const ::std::string& value);
    inline void set_description(const char* value);
    inline void set_description(const char* value, size_t size);
    inline ::std::string* mutable_description();
    inline ::std::string* release_description();
    inline void set_allocated_description(::std::string* description);

    // repeated uint32 links_add = 6;
    inline int links_add_size() const;
    inline void clear_links_add();
    static const int kLinksAddFieldNumber = 6;
    inline ::google::protobuf::uint32 links_add(int index) const;
    inline void set_links_add(int index, ::google::protobuf::uint32 value);
    inline void add_links_add(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    links_add() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_links_add();

    // repeated uint32 links_remove = 7;
    inline int links_remove_size() const;
    inline void clear_links_remove();
    static const int kLinksRemoveFieldNumber = 7;
    inline ::google::protobuf::uint32 links_remove(int index) const;
    inline void set_links_remove(int index, ::google::protobuf::uint32 value);
    inline void add_links_remove(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    links_remove() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_links_remove();

    // optional bool temporary = 8 [default = false];
    inline bool has_temporary() const;
    inline void clear_temporary();
    static const int kTemporaryFieldNumber = 8;
    inline bool temporary() const;
    inline void set_temporary(bool value);

    // optional int32 position = 9 [default = 0];
    inline bool has_position() const;
    inline void clear_position();
    static const int kPositionFieldNumber = 9;
    inline ::google::protobuf::int32 position() const;
    inline void set_position(::google::protobuf::int32 value);

    // optional bytes description_hash = 10;
    inline bool has_description_hash() const;
    inline void clear_description_hash();
    static const int kDescriptionHashFieldNumber = 10;
    inline const ::std::string& description_hash() const;
    inline void set_description_hash(const ::std::string& value);
    inline void set_description_hash(const char* value);
    inline void set_description_hash(const void* value, size_t size);
    inline ::std::string* mutable_description_hash();
    inline ::std::string* release_description_hash();
    inline void set_allocated_description_hash(::std::string* description_hash);

    // optional uint32 max_users = 11;
    inline bool has_max_users() const;
    inline void clear_max_users();
    static const int kMaxUsersFieldNumber = 11;
    inline ::google::protobuf::uint32 max_users() const;
    inline void set_max_users(::google::protobuf::uint32 value);

    // @@protoc_insertion_point(class_scope:MumbleProto.ChannelState)
  private:
    inline void set_has_channel_id();
    inline void clear_has_channel_id();
    inline void set_has_parent();
    inline void clear_has_parent();
    inline void set_has_name();
    inline void clear_has_name();
    inline void set_has_description();
    inline void clear_has_description();
    inline void set_has_temporary();
    inline void clear_has_temporary();
    inline void set_has_position();
    inline void clear_has_position();
    inline void set_has_description_hash();
    inline void clear_has_description_hash();
    inline void set_has_max_users();
    inline void clear_has_max_users();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 channel_id_;
    ::google::protobuf::uint32 parent_;
    ::std::string* name_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_;
    ::std::string* description_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_add_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_remove_;
    bool temporary_;
    ::google::protobuf::int32 position_;
    ::std::string* description_hash_;
    ::google::protobuf::uint32 max_users_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static ChannelState* default_instance_;
  };
// -------------------------------------------------------------------

  class UserRemove : public ::google::protobuf::Message
  {
  public:
    UserRemove();
    virtual ~UserRemove();

    UserRemove(const UserRemove& from);

    inline UserRemove& operator=(const UserRemove& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const UserRemove& default_instance();

    void Swap(UserRemove* other);

    // implements Message ----------------------------------------------

    UserRemove* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const UserRemove& from);
    void MergeFrom(const UserRemove& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required uint32 session = 1;
    inline bool has_session() const;
    inline void clear_session();
    static const int kSessionFieldNumber = 1;
    inline ::google::protobuf::uint32 session() const;
    inline void set_session(::google::protobuf::uint32 value);

    // optional uint32 actor = 2;
    inline bool has_actor() const;
    inline void clear_actor();
    static const int kActorFieldNumber = 2;
    inline ::google::protobuf::uint32 actor() const;
    inline void set_actor(::google::protobuf::uint32 value);

    // optional string reason = 3;
    inline bool has_reason() const;
    inline void clear_reason();
    static const int kReasonFieldNumber = 3;
    inline const ::std::string& reason() const;
    inline void set_reason(const ::std::string& value);
    inline void set_reason(const char* value);
    inline void set_reason(const char* value, size_t size);
    inline ::std::string* mutable_reason();
    inline ::std::string* release_reason();
    inline void set_allocated_reason(::std::string* reason);

    // optional bool ban = 4;
    inline bool has_ban() const;
    inline void clear_ban();
    static const int kBanFieldNumber = 4;
    inline bool ban() const;
    inline void set_ban(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.UserRemove)
  private:
    inline void set_has_session();
    inline void clear_has_session();
    inline void set_has_actor();
    inline void clear_has_actor();
    inline void set_has_reason();
    inline void clear_has_reason();
    inline void set_has_ban();
    inline void clear_has_ban();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 session_;
    ::google::protobuf::uint32 actor_;
    ::std::string* reason_;
    bool ban_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static UserRemove* default_instance_;
  };
// -------------------------------------------------------------------

  class UserState : public ::google::protobuf::Message
  {
  public:
    UserState();
    virtual ~UserState();

    UserState(const UserState& from);

    inline UserState& operator=(const UserState& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const UserState& default_instance();

    void Swap(UserState* other);

    // implements Message ----------------------------------------------

    UserState* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const UserState& from);
    void MergeFrom(const UserState& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 session = 1;
    inline bool has_session() const;
    inline void clear_session();
    static const int kSessionFieldNumber = 1;
    inline ::google::protobuf::uint32 session() const;
    inline void set_session(::google::protobuf::uint32 value);

    // optional uint32 actor = 2;
    inline bool has_actor() const;
    inline void clear_actor();
    static const int kActorFieldNumber = 2;
    inline ::google::protobuf::uint32 actor() const;
    inline void set_actor(::google::protobuf::uint32 value);

    // optional string name = 3;
    inline bool has_name() const;
    inline void clear_name();
    static const int kNameFieldNumber = 3;
    inline const ::std::string& name() const;
    inline void set_name(const ::std::string& value);
    inline void set_name(const char* value);
    inline void set_name(const char* value, size_t size);
    inline ::std::string* mutable_name();
    inline ::std::string* release_name();
    inline void set_allocated_name(::std::string* name);

    // optional uint32 user_id = 4;
    inline bool has_user_id() const;
    inline void clear_user_id();
    static const int kUserIdFieldNumber = 4;
    inline ::google::protobuf::uint32 user_id() const;
    inline void set_user_id(::google::protobuf::uint32 value);

    // optional uint32 channel_id = 5;
    inline bool has_channel_id() const;
    inline void clear_channel_id();
    static const int kChannelIdFieldNumber = 5;
    inline ::google::protobuf::uint32 channel_id() const;
    inline void set_channel_id(::google::protobuf::uint32 value);

    // optional bool mute = 6;
    inline bool has_mute() const;
    inline void clear_mute();
    static const int kMuteFieldNumber = 6;
    inline bool mute() const;
    inline void set_mute(bool value);

    // optional bool deaf = 7;
    inline bool has_deaf() const;
    inline void clear_deaf();
    static const int kDeafFieldNumber = 7;
    inline bool deaf() const;
    inline void set_deaf(bool value);

    // optional bool suppress = 8;
    inline bool has_suppress() const;
    inline void clear_suppress();
    static const int kSuppressFieldNumber = 8;
    inline bool suppress() const;
    inline void set_suppress(bool value);

    // optional bool self_mute = 9;
    inline bool has_self_mute() const;
    inline void clear_self_mute();
    static const int kSelfMuteFieldNumber = 9;
    inline bool self_mute() const;
    inline void set_self_mute(bool value);

    // optional bool self_deaf = 10;
    inline bool has_self_deaf() const;
    inline void clear_self_deaf();
    static const int kSelfDeafFieldNumber = 10;
    inline bool self_deaf() const;
    inline void set_self_deaf(bool value);

    // optional bytes texture = 11;
    inline bool has_texture() const;
    inline void clear_texture();
    static const int kTextureFieldNumber = 11;
    inline const ::std::string& texture() const;
    inline void set_texture(const ::std::string& value);
    inline void set_texture(const char* value);
    inline void set_texture(const void* value, size_t size);
    inline ::std::string* mutable_texture();
    inline ::std::string* release_texture();
    inline void set_allocated_texture(::std::string* texture);

    // optional bytes plugin_context = 12;
    inline bool has_plugin_context() const;
    inline void clear_plugin_context();
    static const int kPluginContextFieldNumber = 12;
    inline const ::std::string& plugin_context() const;
    inline void set_plugin_context(const ::std::string& value);
    inline void set_plugin_context(const char* value);
    inline void set_plugin_context(const void* value, size_t size);
    inline ::std::string* mutable_plugin_context();
    inline ::std::string* release_plugin_context();
    inline void set_allocated_plugin_context(::std::string* plugin_context);

    // optional string plugin_identity = 13;
    inline bool has_plugin_identity() const;
    inline void clear_plugin_identity();
    static const int kPluginIdentityFieldNumber = 13;
    inline const ::std::string& plugin_identity() const;
    inline void set_plugin_identity(const ::std::string& value);
    inline void set_plugin_identity(const char* value);
    inline void set_plugin_identity(const char* value, size_t size);
    inline ::std::string* mutable_plugin_identity();
    inline ::std::string* release_plugin_identity();
    inline void set_allocated_plugin_identity(::std::string* plugin_identity);

    // optional string comment = 14;
    inline bool has_comment() const;
    inline void clear_comment();
    static const int kCommentFieldNumber = 14;
    inline const ::std::string& comment() const;
    inline void set_comment(const ::std::string& value);
    inline void set_comment(const char* value);
    inline void set_comment(const char* value, size_t size);
    inline ::std::string* mutable_comment();
    inline ::std::string* release_comment();
    inline void set_allocated_comment(::std::string* comment);

    // optional string hash = 15;
    inline bool has_hash() const;
    inline void clear_hash();
    static const int kHashFieldNumber = 15;
    inline const ::std::string& hash() const;
    inline void set_hash(const ::std::string& value);
    inline void set_hash(const char* value);
    inline void set_hash(const char* value, size_t size);
    inline ::std::string* mutable_hash();
    inline ::std::string* release_hash();
    inline void set_allocated_hash(::std::string* hash);

    // optional bytes comment_hash = 16;
    inline bool has_comment_hash() const;
    inline void clear_comment_hash();
    static const int kCommentHashFieldNumber = 16;
    inline const ::std::string& comment_hash() const;
    inline void set_comment_hash(const ::std::string& value);
    inline void set_comment_hash(const char* value);
    inline void set_comment_hash(const void* value, size_t size);
    inline ::std::string* mutable_comment_hash();
    inline ::std::string* release_comment_hash();
    inline void set_allocated_comment_hash(::std::string* comment_hash);

    // optional bytes texture_hash = 17;
    inline bool has_texture_hash() const;
    inline void clear_texture_hash();
    static const int kTextureHashFieldNumber = 17;
    inline const ::std::string& texture_hash() const;
    inline void set_texture_hash(const ::std::string& value);
    inline void set_texture_hash(const char* value);
    inline void set_texture_hash(const void* value, size_t size);
    inline ::std::string* mutable_texture_hash();
    inline ::std::string* release_texture_hash();
    inline void set_allocated_texture_hash(::std::string* texture_hash);

    // optional bool priority_speaker = 18;
    inline bool has_priority_speaker() const;
    inline void clear_priority_speaker();
    static const int kPrioritySpeakerFieldNumber = 18;
    inline bool priority_speaker() const;
    inline void set_priority_speaker(bool value);

    // optional bool recording = 19;
    inline bool has_recording() const;
    inline void clear_recording();
    static const int kRecordingFieldNumber = 19;
    inline bool recording() const;
    inline void set_recording(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.UserState)
  private:
    inline void set_has_session();
    inline void clear_has_session();
    inline void set_has_actor();
    inline void clear_has_actor();
    inline void set_has_name();
    inline void clear_has_name();
    inline void set_has_user_id();
    inline void clear_has_user_id();
    inline void set_has_channel_id();
    inline void clear_has_channel_id();
    inline void set_has_mute();
    inline void clear_has_mute();
    inline void set_has_deaf();
    inline void clear_has_deaf();
    inline void set_has_suppress();
    inline void clear_has_suppress();
    inline void set_has_self_mute();
    inline void clear_has_self_mute();
    inline void set_has_self_deaf();
    inline void clear_has_self_deaf();
    inline void set_has_texture();
    inline void clear_has_texture();
    inline void set_has_plugin_context();
    inline void clear_has_plugin_context();
    inline void set_has_plugin_identity();
    inline void clear_has_plugin_identity();
    inline void set_has_comment();
    inline void clear_has_comment();
    inline void set_has_hash();
    inline void clear_has_hash();
    inline void set_has_comment_hash();
    inline void clear_has_comment_hash();
    inline void set_has_texture_hash();
    inline void clear_has_texture_hash();
    inline void set_has_priority_speaker();
    inline void clear_has_priority_speaker();
    inline void set_has_recording();
    inline void clear_has_recording();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 session_;
    ::google::protobuf::uint32 actor_;
    ::std::string* name_;
    ::google::protobuf::uint32 user_id_;
    ::google::protobuf::uint32 channel_id_;
    ::std::string* texture_;
    bool mute_;
    bool deaf_;
    bool suppress_;
    bool self_mute_;
    bool self_deaf_;
    bool priority_speaker_;
    bool recording_;
    ::std::string* plugin_context_;
    ::std::string* plugin_identity_;
    ::std::string* comment_;
    ::std::string* hash_;
    ::std::string* comment_hash_;
    ::std::string* texture_hash_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static UserState* default_instance_;
  };
// -------------------------------------------------------------------

  class BanList_BanEntry : public ::google::protobuf::Message
  {
  public:
    BanList_BanEntry();
    virtual ~BanList_BanEntry();

    BanList_BanEntry(const BanList_BanEntry& from);

    inline BanList_BanEntry& operator=(const BanList_BanEntry& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const BanList_BanEntry& default_instance();

    void Swap(BanList_BanEntry* other);

    // implements Message ----------------------------------------------

    BanList_BanEntry* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const BanList_BanEntry& from);
    void MergeFrom(const BanList_BanEntry& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required bytes address = 1;
    inline bool has_address() const;
    inline void clear_address();
    static const int kAddressFieldNumber = 1;
    inline const ::std::string& address() const;
    inline void set_address(const ::std::string& value);
    inline void set_address(const char* value);
    inline void set_address(const void* value, size_t size);
    inline ::std::string* mutable_address();
    inline ::std::string* release_address();
    inline void set_allocated_address(::std::string* address);

    // required uint32 mask = 2;
    inline bool has_mask() const;
    inline void clear_mask();
    static const int kMaskFieldNumber = 2;
    inline ::google::protobuf::uint32 mask() const;
    inline void set_mask(::google::protobuf::uint32 value);

    // optional string name = 3;
    inline bool has_name() const;
    inline void clear_name();
    static const int kNameFieldNumber = 3;
    inline const ::std::string& name() const;
    inline void set_name(const ::std::string& value);
    inline void set_name(const char* value);
    inline void set_name(const char* value, size_t size);
    inline ::std::string* mutable_name();
    inline ::std::string* release_name();
    inline void set_allocated_name(::std::string* name);

    // optional string hash = 4;
    inline bool has_hash() const;
    inline void clear_hash();
    static const int kHashFieldNumber = 4;
    inline const ::std::string& hash() const;
    inline void set_hash(const ::std::string& value);
    inline void set_hash(const char* value);
    inline void set_hash(const char* value, size_t size);
    inline ::std::string* mutable_hash();
    inline ::std::string* release_hash();
    inline void set_allocated_hash(::std::string* hash);

    // optional string reason = 5;
    inline bool has_reason() const;
    inline void clear_reason();
    static const int kReasonFieldNumber = 5;
    inline const ::std::string& reason() const;
    inline void set_reason(const ::std::string& value);
    inline void set_reason(const char* value);
    inline void set_reason(const char* value, size_t size);
    inline ::std::string* mutable_reason();
    inline ::std::string* release_reason();
    inline void set_allocated_reason(::std::string* reason);

    // optional string start = 6;
    inline bool has_start() const;
    inline void clear_start();
    static const int kStartFieldNumber = 6;
    inline const ::std::string& start() const;
    inline void set_start(const ::std::string& value);
    inline void set_start(const char* value);
    inline void set_start(const char* value, size_t size);
    inline ::std::string* mutable_start();
    inline ::std::string* release_start();
    inline void set_allocated_start(::std::string* start);

    // optional uint32 duration = 7;
    inline bool has_duration() const;
    inline void clear_duration();
    static const int kDurationFieldNumber = 7;
    inline ::google::protobuf::uint32 duration() const;
    inline void set_duration(::google::protobuf::uint32 value);

    // @@protoc_insertion_point(class_scope:MumbleProto.BanList.BanEntry)
  private:
    inline void set_has_address();
    inline void clear_has_address();
    inline void set_has_mask();
    inline void clear_has_mask();
    inline void set_has_name();
    inline void clear_has_name();
    inline void set_has_hash();
    inline void clear_has_hash();
    inline void set_has_reason();
    inline void clear_has_reason();
    inline void set_has_start();
    inline void clear_has_start();
    inline void set_has_duration();
    inline void clear_has_duration();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* address_;
    ::std::string* name_;
    ::std::string* hash_;
    ::google::protobuf::uint32 mask_;
    ::google::protobuf::uint32 duration_;
    ::std::string* reason_;
    ::std::string* start_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static BanList_BanEntry* default_instance_;
  };
// -------------------------------------------------------------------

  class BanList : public ::google::protobuf::Message
  {
  public:
    BanList();
    virtual ~BanList();

    BanList(const BanList& from);

    inline BanList& operator=(const BanList& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const BanList& default_instance();

    void Swap(BanList* other);

    // implements Message ----------------------------------------------

    BanList* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const BanList& from);
    void MergeFrom(const BanList& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    typedef BanList_BanEntry BanEntry;

    // accessors -------------------------------------------------------

    // repeated .MumbleProto.BanList.BanEntry bans = 1;
    inline int bans_size() const;
    inline void clear_bans();
    static const int kBansFieldNumber = 1;
    inline const ::MumbleProto::BanList_BanEntry& bans(int index) const;
    inline ::MumbleProto::BanList_BanEntry* mutable_bans(int index);
    inline ::MumbleProto::BanList_BanEntry* add_bans();
    inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
    bans() const;
    inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
    mutable_bans();

    // optional bool query = 2 [default = false];
    inline bool has_query() const;
    inline void clear_query();
    static const int kQueryFieldNumber = 2;
    inline bool query() const;
    inline void set_query(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.BanList)
  private:
    inline void set_has_query();
    inline void clear_has_query();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry > bans_;
    bool query_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static BanList* default_instance_;
  };
// -------------------------------------------------------------------

  class TextMessage : public ::google::protobuf::Message
  {
  public:
    TextMessage();
    virtual ~TextMessage();

    TextMessage(const TextMessage& from);

    inline TextMessage& operator=(const TextMessage& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const TextMessage& default_instance();

    void Swap(TextMessage* other);

    // implements Message ----------------------------------------------

    TextMessage* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const TextMessage& from);
    void MergeFrom(const TextMessage& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 actor = 1;
    inline bool has_actor() const;
    inline void clear_actor();
    static const int kActorFieldNumber = 1;
    inline ::google::protobuf::uint32 actor() const;
    inline void set_actor(::google::protobuf::uint32 value);

    // repeated uint32 session = 2;
    inline int session_size() const;
    inline void clear_session();
    static const int kSessionFieldNumber = 2;
    inline ::google::protobuf::uint32 session(int index) const;
    inline void set_session(int index, ::google::protobuf::uint32 value);
    inline void add_session(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    session() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_session();

    // repeated uint32 channel_id = 3;
    inline int channel_id_size() const;
    inline void clear_channel_id();
    static const int kChannelIdFieldNumber = 3;
    inline ::google::protobuf::uint32 channel_id(int index) const;
    inline void set_channel_id(int index, ::google::protobuf::uint32 value);
    inline void add_channel_id(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    channel_id() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_channel_id();

    // repeated uint32 tree_id = 4;
    inline int tree_id_size() const;
    inline void clear_tree_id();
    static const int kTreeIdFieldNumber = 4;
    inline ::google::protobuf::uint32 tree_id(int index) const;
    inline void set_tree_id(int index, ::google::protobuf::uint32 value);
    inline void add_tree_id(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    tree_id() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_tree_id();

    // required string message = 5;
    inline bool has_message() const;
    inline void clear_message();
    static const int kMessageFieldNumber = 5;
    inline const ::std::string& message() const;
    inline void set_message(const ::std::string& value);
    inline void set_message(const char* value);
    inline void set_message(const char* value, size_t size);
    inline ::std::string* mutable_message();
    inline ::std::string* release_message();
    inline void set_allocated_message(::std::string* message);

    // @@protoc_insertion_point(class_scope:MumbleProto.TextMessage)
  private:
    inline void set_has_actor();
    inline void clear_has_actor();
    inline void set_has_message();
    inline void clear_has_message();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channel_id_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tree_id_;
    ::std::string* message_;
    ::google::protobuf::uint32 actor_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static TextMessage* default_instance_;
  };
// -------------------------------------------------------------------

  class PermissionDenied : public ::google::protobuf::Message
  {
  public:
    PermissionDenied();
    virtual ~PermissionDenied();

    PermissionDenied(const PermissionDenied& from);

    inline PermissionDenied& operator=(const PermissionDenied& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const PermissionDenied& default_instance();

    void Swap(PermissionDenied* other);

    // implements Message ----------------------------------------------

    PermissionDenied* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const PermissionDenied& from);
    void MergeFrom(const PermissionDenied& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    typedef PermissionDenied_DenyType DenyType;
    static const DenyType Text = PermissionDenied_DenyType_Text;
    static const DenyType Permission = PermissionDenied_DenyType_Permission;
    static const DenyType SuperUser = PermissionDenied_DenyType_SuperUser;
    static const DenyType ChannelName = PermissionDenied_DenyType_ChannelName;
    static const DenyType TextTooLong = PermissionDenied_DenyType_TextTooLong;
    static const DenyType H9K = PermissionDenied_DenyType_H9K;
    static const DenyType TemporaryChannel =
      PermissionDenied_DenyType_TemporaryChannel;
    static const DenyType MissingCertificate =
      PermissionDenied_DenyType_MissingCertificate;
    static const DenyType UserName = PermissionDenied_DenyType_UserName;
    static const DenyType ChannelFull = PermissionDenied_DenyType_ChannelFull;
    static const DenyType NestingLimit = PermissionDenied_DenyType_NestingLimit;
    static inline bool DenyType_IsValid(int value)
    {
      return PermissionDenied_DenyType_IsValid(value);
    }
    static const DenyType DenyType_MIN =
      PermissionDenied_DenyType_DenyType_MIN;
    static const DenyType DenyType_MAX =
      PermissionDenied_DenyType_DenyType_MAX;
    static const int DenyType_ARRAYSIZE =
      PermissionDenied_DenyType_DenyType_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor*
    DenyType_descriptor()
    {
      return PermissionDenied_DenyType_descriptor();
    }
    static inline const ::std::string& DenyType_Name(DenyType value)
    {
      return PermissionDenied_DenyType_Name(value);
    }
    static inline bool DenyType_Parse(const ::std::string& name,
                                      DenyType* value)
    {
      return PermissionDenied_DenyType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // optional uint32 permission = 1;
    inline bool has_permission() const;
    inline void clear_permission();
    static const int kPermissionFieldNumber = 1;
    inline ::google::protobuf::uint32 permission() const;
    inline void set_permission(::google::protobuf::uint32 value);

    // optional uint32 channel_id = 2;
    inline bool has_channel_id() const;
    inline void clear_channel_id();
    static const int kChannelIdFieldNumber = 2;
    inline ::google::protobuf::uint32 channel_id() const;
    inline void set_channel_id(::google::protobuf::uint32 value);

    // optional uint32 session = 3;
    inline bool has_session() const;
    inline void clear_session();
    static const int kSessionFieldNumber = 3;
    inline ::google::protobuf::uint32 session() const;
    inline void set_session(::google::protobuf::uint32 value);

    // optional string reason = 4;
    inline bool has_reason() const;
    inline void clear_reason();
    static const int kReasonFieldNumber = 4;
    inline const ::std::string& reason() const;
    inline void set_reason(const ::std::string& value);
    inline void set_reason(const char* value);
    inline void set_reason(const char* value, size_t size);
    inline ::std::string* mutable_reason();
    inline ::std::string* release_reason();
    inline void set_allocated_reason(::std::string* reason);

    // optional .MumbleProto.PermissionDenied.DenyType type = 5;
    inline bool has_type() const;
    inline void clear_type();
    static const int kTypeFieldNumber = 5;
    inline ::MumbleProto::PermissionDenied_DenyType type() const;
    inline void set_type(::MumbleProto::PermissionDenied_DenyType value);

    // optional string name = 6;
    inline bool has_name() const;
    inline void clear_name();
    static const int kNameFieldNumber = 6;
    inline const ::std::string& name() const;
    inline void set_name(const ::std::string& value);
    inline void set_name(const char* value);
    inline void set_name(const char* value, size_t size);
    inline ::std::string* mutable_name();
    inline ::std::string* release_name();
    inline void set_allocated_name(::std::string* name);

    // @@protoc_insertion_point(class_scope:MumbleProto.PermissionDenied)
  private:
    inline void set_has_permission();
    inline void clear_has_permission();
    inline void set_has_channel_id();
    inline void clear_has_channel_id();
    inline void set_has_session();
    inline void clear_has_session();
    inline void set_has_reason();
    inline void clear_has_reason();
    inline void set_has_type();
    inline void clear_has_type();
    inline void set_has_name();
    inline void clear_has_name();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 permission_;
    ::google::protobuf::uint32 channel_id_;
    ::std::string* reason_;
    ::google::protobuf::uint32 session_;
    int type_;
    ::std::string* name_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static PermissionDenied* default_instance_;
  };
// -------------------------------------------------------------------

  class ACL_ChanGroup : public ::google::protobuf::Message
  {
  public:
    ACL_ChanGroup();
    virtual ~ACL_ChanGroup();

    ACL_ChanGroup(const ACL_ChanGroup& from);

    inline ACL_ChanGroup& operator=(const ACL_ChanGroup& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ACL_ChanGroup& default_instance();

    void Swap(ACL_ChanGroup* other);

    // implements Message ----------------------------------------------

    ACL_ChanGroup* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ACL_ChanGroup& from);
    void MergeFrom(const ACL_ChanGroup& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required string name = 1;
    inline bool has_name() const;
    inline void clear_name();
    static const int kNameFieldNumber = 1;
    inline const ::std::string& name() const;
    inline void set_name(const ::std::string& value);
    inline void set_name(const char* value);
    inline void set_name(const char* value, size_t size);
    inline ::std::string* mutable_name();
    inline ::std::string* release_name();
    inline void set_allocated_name(::std::string* name);

    // optional bool inherited = 2 [default = true];
    inline bool has_inherited() const;
    inline void clear_inherited();
    static const int kInheritedFieldNumber = 2;
    inline bool inherited() const;
    inline void set_inherited(bool value);

    // optional bool inherit = 3 [default = true];
    inline bool has_inherit() const;
    inline void clear_inherit();
    static const int kInheritFieldNumber = 3;
    inline bool inherit() const;
    inline void set_inherit(bool value);

    // optional bool inheritable = 4 [default = true];
    inline bool has_inheritable() const;
    inline void clear_inheritable();
    static const int kInheritableFieldNumber = 4;
    inline bool inheritable() const;
    inline void set_inheritable(bool value);

    // repeated uint32 add = 5;
    inline int add_size() const;
    inline void clear_add();
    static const int kAddFieldNumber = 5;
    inline ::google::protobuf::uint32 add(int index) const;
    inline void set_add(int index, ::google::protobuf::uint32 value);
    inline void add_add(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    add() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_add();

    // repeated uint32 remove = 6;
    inline int remove_size() const;
    inline void clear_remove();
    static const int kRemoveFieldNumber = 6;
    inline ::google::protobuf::uint32 remove(int index) const;
    inline void set_remove(int index, ::google::protobuf::uint32 value);
    inline void add_remove(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    remove() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_remove();

    // repeated uint32 inherited_members = 7;
    inline int inherited_members_size() const;
    inline void clear_inherited_members();
    static const int kInheritedMembersFieldNumber = 7;
    inline ::google::protobuf::uint32 inherited_members(int index) const;
    inline void set_inherited_members(int index, ::google::protobuf::uint32 value);
    inline void add_inherited_members(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    inherited_members() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_inherited_members();

    // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanGroup)
  private:
    inline void set_has_name();
    inline void clear_has_name();
    inline void set_has_inherited();
    inline void clear_has_inherited();
    inline void set_has_inherit();
    inline void clear_has_inherit();
    inline void set_has_inheritable();
    inline void clear_has_inheritable();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* name_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > add_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > remove_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >
    inherited_members_;
    bool inherited_;
    bool inherit_;
    bool inheritable_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static ACL_ChanGroup* default_instance_;
  };
// -------------------------------------------------------------------

  class ACL_ChanACL : public ::google::protobuf::Message
  {
  public:
    ACL_ChanACL();
    virtual ~ACL_ChanACL();

    ACL_ChanACL(const ACL_ChanACL& from);

    inline ACL_ChanACL& operator=(const ACL_ChanACL& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ACL_ChanACL& default_instance();

    void Swap(ACL_ChanACL* other);

    // implements Message ----------------------------------------------

    ACL_ChanACL* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ACL_ChanACL& from);
    void MergeFrom(const ACL_ChanACL& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bool apply_here = 1 [default = true];
    inline bool has_apply_here() const;
    inline void clear_apply_here();
    static const int kApplyHereFieldNumber = 1;
    inline bool apply_here() const;
    inline void set_apply_here(bool value);

    // optional bool apply_subs = 2 [default = true];
    inline bool has_apply_subs() const;
    inline void clear_apply_subs();
    static const int kApplySubsFieldNumber = 2;
    inline bool apply_subs() const;
    inline void set_apply_subs(bool value);

    // optional bool inherited = 3 [default = true];
    inline bool has_inherited() const;
    inline void clear_inherited();
    static const int kInheritedFieldNumber = 3;
    inline bool inherited() const;
    inline void set_inherited(bool value);

    // optional uint32 user_id = 4;
    inline bool has_user_id() const;
    inline void clear_user_id();
    static const int kUserIdFieldNumber = 4;
    inline ::google::protobuf::uint32 user_id() const;
    inline void set_user_id(::google::protobuf::uint32 value);

    // optional string group = 5;
    inline bool has_group() const;
    inline void clear_group();
    static const int kGroupFieldNumber = 5;
    inline const ::std::string& group() const;
    inline void set_group(const ::std::string& value);
    inline void set_group(const char* value);
    inline void set_group(const char* value, size_t size);
    inline ::std::string* mutable_group();
    inline ::std::string* release_group();
    inline void set_allocated_group(::std::string* group);

    // optional uint32 grant = 6;
    inline bool has_grant() const;
    inline void clear_grant();
    static const int kGrantFieldNumber = 6;
    inline ::google::protobuf::uint32 grant() const;
    inline void set_grant(::google::protobuf::uint32 value);

    // optional uint32 deny = 7;
    inline bool has_deny() const;
    inline void clear_deny();
    static const int kDenyFieldNumber = 7;
    inline ::google::protobuf::uint32 deny() const;
    inline void set_deny(::google::protobuf::uint32 value);

    // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanACL)
  private:
    inline void set_has_apply_here();
    inline void clear_has_apply_here();
    inline void set_has_apply_subs();
    inline void clear_has_apply_subs();
    inline void set_has_inherited();
    inline void clear_has_inherited();
    inline void set_has_user_id();
    inline void clear_has_user_id();
    inline void set_has_group();
    inline void clear_has_group();
    inline void set_has_grant();
    inline void clear_has_grant();
    inline void set_has_deny();
    inline void clear_has_deny();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    bool apply_here_;
    bool apply_subs_;
    bool inherited_;
    ::google::protobuf::uint32 user_id_;
    ::std::string* group_;
    ::google::protobuf::uint32 grant_;
    ::google::protobuf::uint32 deny_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static ACL_ChanACL* default_instance_;
  };
// -------------------------------------------------------------------

  class ACL : public ::google::protobuf::Message
  {
  public:
    ACL();
    virtual ~ACL();

    ACL(const ACL& from);

    inline ACL& operator=(const ACL& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ACL& default_instance();

    void Swap(ACL* other);

    // implements Message ----------------------------------------------

    ACL* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ACL& from);
    void MergeFrom(const ACL& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    typedef ACL_ChanGroup ChanGroup;
    typedef ACL_ChanACL ChanACL;

    // accessors -------------------------------------------------------

    // required uint32 channel_id = 1;
    inline bool has_channel_id() const;
    inline void clear_channel_id();
    static const int kChannelIdFieldNumber = 1;
    inline ::google::protobuf::uint32 channel_id() const;
    inline void set_channel_id(::google::protobuf::uint32 value);

    // optional bool inherit_acls = 2 [default = true];
    inline bool has_inherit_acls() const;
    inline void clear_inherit_acls();
    static const int kInheritAclsFieldNumber = 2;
    inline bool inherit_acls() const;
    inline void set_inherit_acls(bool value);

    // repeated .MumbleProto.ACL.ChanGroup groups = 3;
    inline int groups_size() const;
    inline void clear_groups();
    static const int kGroupsFieldNumber = 3;
    inline const ::MumbleProto::ACL_ChanGroup& groups(int index) const;
    inline ::MumbleProto::ACL_ChanGroup* mutable_groups(int index);
    inline ::MumbleProto::ACL_ChanGroup* add_groups();
    inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
    groups() const;
    inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
    mutable_groups();

    // repeated .MumbleProto.ACL.ChanACL acls = 4;
    inline int acls_size() const;
    inline void clear_acls();
    static const int kAclsFieldNumber = 4;
    inline const ::MumbleProto::ACL_ChanACL& acls(int index) const;
    inline ::MumbleProto::ACL_ChanACL* mutable_acls(int index);
    inline ::MumbleProto::ACL_ChanACL* add_acls();
    inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
    acls() const;
    inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
    mutable_acls();

    // optional bool query = 5 [default = false];
    inline bool has_query() const;
    inline void clear_query();
    static const int kQueryFieldNumber = 5;
    inline bool query() const;
    inline void set_query(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.ACL)
  private:
    inline void set_has_channel_id();
    inline void clear_has_channel_id();
    inline void set_has_inherit_acls();
    inline void clear_has_inherit_acls();
    inline void set_has_query();
    inline void clear_has_query();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 channel_id_;
    bool inherit_acls_;
    bool query_;
    ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup > groups_;
    ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL > acls_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static ACL* default_instance_;
  };
// -------------------------------------------------------------------

  class QueryUsers : public ::google::protobuf::Message
  {
  public:
    QueryUsers();
    virtual ~QueryUsers();

    QueryUsers(const QueryUsers& from);

    inline QueryUsers& operator=(const QueryUsers& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const QueryUsers& default_instance();

    void Swap(QueryUsers* other);

    // implements Message ----------------------------------------------

    QueryUsers* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const QueryUsers& from);
    void MergeFrom(const QueryUsers& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated uint32 ids = 1;
    inline int ids_size() const;
    inline void clear_ids();
    static const int kIdsFieldNumber = 1;
    inline ::google::protobuf::uint32 ids(int index) const;
    inline void set_ids(int index, ::google::protobuf::uint32 value);
    inline void add_ids(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    ids() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_ids();

    // repeated string names = 2;
    inline int names_size() const;
    inline void clear_names();
    static const int kNamesFieldNumber = 2;
    inline const ::std::string& names(int index) const;
    inline ::std::string* mutable_names(int index);
    inline void set_names(int index, const ::std::string& value);
    inline void set_names(int index, const char* value);
    inline void set_names(int index, const char* value, size_t size);
    inline ::std::string* add_names();
    inline void add_names(const ::std::string& value);
    inline void add_names(const char* value);
    inline void add_names(const char* value, size_t size);
    inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names()
    const;
    inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

    // @@protoc_insertion_point(class_scope:MumbleProto.QueryUsers)
  private:

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ids_;
    ::google::protobuf::RepeatedPtrField< ::std::string> names_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static QueryUsers* default_instance_;
  };
// -------------------------------------------------------------------

  class CryptSetup : public ::google::protobuf::Message
  {
  public:
    CryptSetup();
    virtual ~CryptSetup();

    CryptSetup(const CryptSetup& from);

    inline CryptSetup& operator=(const CryptSetup& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const CryptSetup& default_instance();

    void Swap(CryptSetup* other);

    // implements Message ----------------------------------------------

    CryptSetup* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const CryptSetup& from);
    void MergeFrom(const CryptSetup& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes key = 1;
    inline bool has_key() const;
    inline void clear_key();
    static const int kKeyFieldNumber = 1;
    inline const ::std::string& key() const;
    inline void set_key(const ::std::string& value);
    inline void set_key(const char* value);
    inline void set_key(const void* value, size_t size);
    inline ::std::string* mutable_key();
    inline ::std::string* release_key();
    inline void set_allocated_key(::std::string* key);

    // optional bytes client_nonce = 2;
    inline bool has_client_nonce() const;
    inline void clear_client_nonce();
    static const int kClientNonceFieldNumber = 2;
    inline const ::std::string& client_nonce() const;
    inline void set_client_nonce(const ::std::string& value);
    inline void set_client_nonce(const char* value);
    inline void set_client_nonce(const void* value, size_t size);
    inline ::std::string* mutable_client_nonce();
    inline ::std::string* release_client_nonce();
    inline void set_allocated_client_nonce(::std::string* client_nonce);

    // optional bytes server_nonce = 3;
    inline bool has_server_nonce() const;
    inline void clear_server_nonce();
    static const int kServerNonceFieldNumber = 3;
    inline const ::std::string& server_nonce() const;
    inline void set_server_nonce(const ::std::string& value);
    inline void set_server_nonce(const char* value);
    inline void set_server_nonce(const void* value, size_t size);
    inline ::std::string* mutable_server_nonce();
    inline ::std::string* release_server_nonce();
    inline void set_allocated_server_nonce(::std::string* server_nonce);

    // @@protoc_insertion_point(class_scope:MumbleProto.CryptSetup)
  private:
    inline void set_has_key();
    inline void clear_has_key();
    inline void set_has_client_nonce();
    inline void clear_has_client_nonce();
    inline void set_has_server_nonce();
    inline void clear_has_server_nonce();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* key_;
    ::std::string* client_nonce_;
    ::std::string* server_nonce_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static CryptSetup* default_instance_;
  };
// -------------------------------------------------------------------

  class ContextActionModify : public ::google::protobuf::Message
  {
  public:
    ContextActionModify();
    virtual ~ContextActionModify();

    ContextActionModify(const ContextActionModify& from);

    inline ContextActionModify& operator=(const ContextActionModify& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ContextActionModify& default_instance();

    void Swap(ContextActionModify* other);

    // implements Message ----------------------------------------------

    ContextActionModify* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ContextActionModify& from);
    void MergeFrom(const ContextActionModify& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    typedef ContextActionModify_Context Context;
    static const Context Server = ContextActionModify_Context_Server;
    static const Context Channel = ContextActionModify_Context_Channel;
    static const Context User = ContextActionModify_Context_User;
    static inline bool Context_IsValid(int value)
    {
      return ContextActionModify_Context_IsValid(value);
    }
    static const Context Context_MIN =
      ContextActionModify_Context_Context_MIN;
    static const Context Context_MAX =
      ContextActionModify_Context_Context_MAX;
    static const int Context_ARRAYSIZE =
      ContextActionModify_Context_Context_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor*
    Context_descriptor()
    {
      return ContextActionModify_Context_descriptor();
    }
    static inline const ::std::string& Context_Name(Context value)
    {
      return ContextActionModify_Context_Name(value);
    }
    static inline bool Context_Parse(const ::std::string& name,
                                     Context* value)
    {
      return ContextActionModify_Context_Parse(name, value);
    }

    typedef ContextActionModify_Operation Operation;
    static const Operation Add = ContextActionModify_Operation_Add;
    static const Operation Remove = ContextActionModify_Operation_Remove;
    static inline bool Operation_IsValid(int value)
    {
      return ContextActionModify_Operation_IsValid(value);
    }
    static const Operation Operation_MIN =
      ContextActionModify_Operation_Operation_MIN;
    static const Operation Operation_MAX =
      ContextActionModify_Operation_Operation_MAX;
    static const int Operation_ARRAYSIZE =
      ContextActionModify_Operation_Operation_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor*
    Operation_descriptor()
    {
      return ContextActionModify_Operation_descriptor();
    }
    static inline const ::std::string& Operation_Name(Operation value)
    {
      return ContextActionModify_Operation_Name(value);
    }
    static inline bool Operation_Parse(const ::std::string& name,
                                       Operation* value)
    {
      return ContextActionModify_Operation_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // required string action = 1;
    inline bool has_action() const;
    inline void clear_action();
    static const int kActionFieldNumber = 1;
    inline const ::std::string& action() const;
    inline void set_action(const ::std::string& value);
    inline void set_action(const char* value);
    inline void set_action(const char* value, size_t size);
    inline ::std::string* mutable_action();
    inline ::std::string* release_action();
    inline void set_allocated_action(::std::string* action);

    // optional string text = 2;
    inline bool has_text() const;
    inline void clear_text();
    static const int kTextFieldNumber = 2;
    inline const ::std::string& text() const;
    inline void set_text(const ::std::string& value);
    inline void set_text(const char* value);
    inline void set_text(const char* value, size_t size);
    inline ::std::string* mutable_text();
    inline ::std::string* release_text();
    inline void set_allocated_text(::std::string* text);

    // optional uint32 context = 3;
    inline bool has_context() const;
    inline void clear_context();
    static const int kContextFieldNumber = 3;
    inline ::google::protobuf::uint32 context() const;
    inline void set_context(::google::protobuf::uint32 value);

    // optional .MumbleProto.ContextActionModify.Operation operation = 4;
    inline bool has_operation() const;
    inline void clear_operation();
    static const int kOperationFieldNumber = 4;
    inline ::MumbleProto::ContextActionModify_Operation operation() const;
    inline void set_operation(::MumbleProto::ContextActionModify_Operation value);

    // @@protoc_insertion_point(class_scope:MumbleProto.ContextActionModify)
  private:
    inline void set_has_action();
    inline void clear_has_action();
    inline void set_has_text();
    inline void clear_has_text();
    inline void set_has_context();
    inline void clear_has_context();
    inline void set_has_operation();
    inline void clear_has_operation();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* action_;
    ::std::string* text_;
    ::google::protobuf::uint32 context_;
    int operation_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static ContextActionModify* default_instance_;
  };
// -------------------------------------------------------------------

  class ContextAction : public ::google::protobuf::Message
  {
  public:
    ContextAction();
    virtual ~ContextAction();

    ContextAction(const ContextAction& from);

    inline ContextAction& operator=(const ContextAction& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ContextAction& default_instance();

    void Swap(ContextAction* other);

    // implements Message ----------------------------------------------

    ContextAction* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ContextAction& from);
    void MergeFrom(const ContextAction& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 session = 1;
    inline bool has_session() const;
    inline void clear_session();
    static const int kSessionFieldNumber = 1;
    inline ::google::protobuf::uint32 session() const;
    inline void set_session(::google::protobuf::uint32 value);

    // optional uint32 channel_id = 2;
    inline bool has_channel_id() const;
    inline void clear_channel_id();
    static const int kChannelIdFieldNumber = 2;
    inline ::google::protobuf::uint32 channel_id() const;
    inline void set_channel_id(::google::protobuf::uint32 value);

    // required string action = 3;
    inline bool has_action() const;
    inline void clear_action();
    static const int kActionFieldNumber = 3;
    inline const ::std::string& action() const;
    inline void set_action(const ::std::string& value);
    inline void set_action(const char* value);
    inline void set_action(const char* value, size_t size);
    inline ::std::string* mutable_action();
    inline ::std::string* release_action();
    inline void set_allocated_action(::std::string* action);

    // @@protoc_insertion_point(class_scope:MumbleProto.ContextAction)
  private:
    inline void set_has_session();
    inline void clear_has_session();
    inline void set_has_channel_id();
    inline void clear_has_channel_id();
    inline void set_has_action();
    inline void clear_has_action();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 session_;
    ::google::protobuf::uint32 channel_id_;
    ::std::string* action_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static ContextAction* default_instance_;
  };
// -------------------------------------------------------------------

  class UserList_User : public ::google::protobuf::Message
  {
  public:
    UserList_User();
    virtual ~UserList_User();

    UserList_User(const UserList_User& from);

    inline UserList_User& operator=(const UserList_User& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const UserList_User& default_instance();

    void Swap(UserList_User* other);

    // implements Message ----------------------------------------------

    UserList_User* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const UserList_User& from);
    void MergeFrom(const UserList_User& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required uint32 user_id = 1;
    inline bool has_user_id() const;
    inline void clear_user_id();
    static const int kUserIdFieldNumber = 1;
    inline ::google::protobuf::uint32 user_id() const;
    inline void set_user_id(::google::protobuf::uint32 value);

    // optional string name = 2;
    inline bool has_name() const;
    inline void clear_name();
    static const int kNameFieldNumber = 2;
    inline const ::std::string& name() const;
    inline void set_name(const ::std::string& value);
    inline void set_name(const char* value);
    inline void set_name(const char* value, size_t size);
    inline ::std::string* mutable_name();
    inline ::std::string* release_name();
    inline void set_allocated_name(::std::string* name);

    // optional string last_seen = 3;
    inline bool has_last_seen() const;
    inline void clear_last_seen();
    static const int kLastSeenFieldNumber = 3;
    inline const ::std::string& last_seen() const;
    inline void set_last_seen(const ::std::string& value);
    inline void set_last_seen(const char* value);
    inline void set_last_seen(const char* value, size_t size);
    inline ::std::string* mutable_last_seen();
    inline ::std::string* release_last_seen();
    inline void set_allocated_last_seen(::std::string* last_seen);

    // optional uint32 last_channel = 4;
    inline bool has_last_channel() const;
    inline void clear_last_channel();
    static const int kLastChannelFieldNumber = 4;
    inline ::google::protobuf::uint32 last_channel() const;
    inline void set_last_channel(::google::protobuf::uint32 value);

    // @@protoc_insertion_point(class_scope:MumbleProto.UserList.User)
  private:
    inline void set_has_user_id();
    inline void clear_has_user_id();
    inline void set_has_name();
    inline void clear_has_name();
    inline void set_has_last_seen();
    inline void clear_has_last_seen();
    inline void set_has_last_channel();
    inline void clear_has_last_channel();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* name_;
    ::google::protobuf::uint32 user_id_;
    ::google::protobuf::uint32 last_channel_;
    ::std::string* last_seen_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static UserList_User* default_instance_;
  };
// -------------------------------------------------------------------

  class UserList : public ::google::protobuf::Message
  {
  public:
    UserList();
    virtual ~UserList();

    UserList(const UserList& from);

    inline UserList& operator=(const UserList& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const UserList& default_instance();

    void Swap(UserList* other);

    // implements Message ----------------------------------------------

    UserList* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const UserList& from);
    void MergeFrom(const UserList& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    typedef UserList_User User;

    // accessors -------------------------------------------------------

    // repeated .MumbleProto.UserList.User users = 1;
    inline int users_size() const;
    inline void clear_users();
    static const int kUsersFieldNumber = 1;
    inline const ::MumbleProto::UserList_User& users(int index) const;
    inline ::MumbleProto::UserList_User* mutable_users(int index);
    inline ::MumbleProto::UserList_User* add_users();
    inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >&
    users() const;
    inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >*
    mutable_users();

    // @@protoc_insertion_point(class_scope:MumbleProto.UserList)
  private:

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User > users_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static UserList* default_instance_;
  };
// -------------------------------------------------------------------

  class VoiceTarget_Target : public ::google::protobuf::Message
  {
  public:
    VoiceTarget_Target();
    virtual ~VoiceTarget_Target();

    VoiceTarget_Target(const VoiceTarget_Target& from);

    inline VoiceTarget_Target& operator=(const VoiceTarget_Target& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const VoiceTarget_Target& default_instance();

    void Swap(VoiceTarget_Target* other);

    // implements Message ----------------------------------------------

    VoiceTarget_Target* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const VoiceTarget_Target& from);
    void MergeFrom(const VoiceTarget_Target& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated uint32 session = 1;
    inline int session_size() const;
    inline void clear_session();
    static const int kSessionFieldNumber = 1;
    inline ::google::protobuf::uint32 session(int index) const;
    inline void set_session(int index, ::google::protobuf::uint32 value);
    inline void add_session(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    session() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_session();

    // optional uint32 channel_id = 2;
    inline bool has_channel_id() const;
    inline void clear_channel_id();
    static const int kChannelIdFieldNumber = 2;
    inline ::google::protobuf::uint32 channel_id() const;
    inline void set_channel_id(::google::protobuf::uint32 value);

    // optional string group = 3;
    inline bool has_group() const;
    inline void clear_group();
    static const int kGroupFieldNumber = 3;
    inline const ::std::string& group() const;
    inline void set_group(const ::std::string& value);
    inline void set_group(const char* value);
    inline void set_group(const char* value, size_t size);
    inline ::std::string* mutable_group();
    inline ::std::string* release_group();
    inline void set_allocated_group(::std::string* group);

    // optional bool links = 4 [default = false];
    inline bool has_links() const;
    inline void clear_links();
    static const int kLinksFieldNumber = 4;
    inline bool links() const;
    inline void set_links(bool value);

    // optional bool children = 5 [default = false];
    inline bool has_children() const;
    inline void clear_children();
    static const int kChildrenFieldNumber = 5;
    inline bool children() const;
    inline void set_children(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget.Target)
  private:
    inline void set_has_channel_id();
    inline void clear_has_channel_id();
    inline void set_has_group();
    inline void clear_has_group();
    inline void set_has_links();
    inline void clear_has_links();
    inline void set_has_children();
    inline void clear_has_children();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_;
    ::std::string* group_;
    ::google::protobuf::uint32 channel_id_;
    bool links_;
    bool children_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static VoiceTarget_Target* default_instance_;
  };
// -------------------------------------------------------------------

  class VoiceTarget : public ::google::protobuf::Message
  {
  public:
    VoiceTarget();
    virtual ~VoiceTarget();

    VoiceTarget(const VoiceTarget& from);

    inline VoiceTarget& operator=(const VoiceTarget& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const VoiceTarget& default_instance();

    void Swap(VoiceTarget* other);

    // implements Message ----------------------------------------------

    VoiceTarget* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const VoiceTarget& from);
    void MergeFrom(const VoiceTarget& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    typedef VoiceTarget_Target Target;

    // accessors -------------------------------------------------------

    // optional uint32 id = 1;
    inline bool has_id() const;
    inline void clear_id();
    static const int kIdFieldNumber = 1;
    inline ::google::protobuf::uint32 id() const;
    inline void set_id(::google::protobuf::uint32 value);

    // repeated .MumbleProto.VoiceTarget.Target targets = 2;
    inline int targets_size() const;
    inline void clear_targets();
    static const int kTargetsFieldNumber = 2;
    inline const ::MumbleProto::VoiceTarget_Target& targets(int index) const;
    inline ::MumbleProto::VoiceTarget_Target* mutable_targets(int index);
    inline ::MumbleProto::VoiceTarget_Target* add_targets();
    inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
    targets() const;
    inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
    mutable_targets();

    // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget)
  private:
    inline void set_has_id();
    inline void clear_has_id();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >
    targets_;
    ::google::protobuf::uint32 id_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static VoiceTarget* default_instance_;
  };
// -------------------------------------------------------------------

  class PermissionQuery : public ::google::protobuf::Message
  {
  public:
    PermissionQuery();
    virtual ~PermissionQuery();

    PermissionQuery(const PermissionQuery& from);

    inline PermissionQuery& operator=(const PermissionQuery& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const PermissionQuery& default_instance();

    void Swap(PermissionQuery* other);

    // implements Message ----------------------------------------------

    PermissionQuery* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const PermissionQuery& from);
    void MergeFrom(const PermissionQuery& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 channel_id = 1;
    inline bool has_channel_id() const;
    inline void clear_channel_id();
    static const int kChannelIdFieldNumber = 1;
    inline ::google::protobuf::uint32 channel_id() const;
    inline void set_channel_id(::google::protobuf::uint32 value);

    // optional uint32 permissions = 2;
    inline bool has_permissions() const;
    inline void clear_permissions();
    static const int kPermissionsFieldNumber = 2;
    inline ::google::protobuf::uint32 permissions() const;
    inline void set_permissions(::google::protobuf::uint32 value);

    // optional bool flush = 3 [default = false];
    inline bool has_flush() const;
    inline void clear_flush();
    static const int kFlushFieldNumber = 3;
    inline bool flush() const;
    inline void set_flush(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.PermissionQuery)
  private:
    inline void set_has_channel_id();
    inline void clear_has_channel_id();
    inline void set_has_permissions();
    inline void clear_has_permissions();
    inline void set_has_flush();
    inline void clear_has_flush();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 channel_id_;
    ::google::protobuf::uint32 permissions_;
    bool flush_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static PermissionQuery* default_instance_;
  };
// -------------------------------------------------------------------

  class CodecVersion : public ::google::protobuf::Message
  {
  public:
    CodecVersion();
    virtual ~CodecVersion();

    CodecVersion(const CodecVersion& from);

    inline CodecVersion& operator=(const CodecVersion& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const CodecVersion& default_instance();

    void Swap(CodecVersion* other);

    // implements Message ----------------------------------------------

    CodecVersion* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const CodecVersion& from);
    void MergeFrom(const CodecVersion& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required int32 alpha = 1;
    inline bool has_alpha() const;
    inline void clear_alpha();
    static const int kAlphaFieldNumber = 1;
    inline ::google::protobuf::int32 alpha() const;
    inline void set_alpha(::google::protobuf::int32 value);

    // required int32 beta = 2;
    inline bool has_beta() const;
    inline void clear_beta();
    static const int kBetaFieldNumber = 2;
    inline ::google::protobuf::int32 beta() const;
    inline void set_beta(::google::protobuf::int32 value);

    // required bool prefer_alpha = 3 [default = true];
    inline bool has_prefer_alpha() const;
    inline void clear_prefer_alpha();
    static const int kPreferAlphaFieldNumber = 3;
    inline bool prefer_alpha() const;
    inline void set_prefer_alpha(bool value);

    // optional bool opus = 4 [default = false];
    inline bool has_opus() const;
    inline void clear_opus();
    static const int kOpusFieldNumber = 4;
    inline bool opus() const;
    inline void set_opus(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.CodecVersion)
  private:
    inline void set_has_alpha();
    inline void clear_has_alpha();
    inline void set_has_beta();
    inline void clear_has_beta();
    inline void set_has_prefer_alpha();
    inline void clear_has_prefer_alpha();
    inline void set_has_opus();
    inline void clear_has_opus();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::int32 alpha_;
    ::google::protobuf::int32 beta_;
    bool prefer_alpha_;
    bool opus_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static CodecVersion* default_instance_;
  };
// -------------------------------------------------------------------

  class UserStats_Stats : public ::google::protobuf::Message
  {
  public:
    UserStats_Stats();
    virtual ~UserStats_Stats();

    UserStats_Stats(const UserStats_Stats& from);

    inline UserStats_Stats& operator=(const UserStats_Stats& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const UserStats_Stats& default_instance();

    void Swap(UserStats_Stats* other);

    // implements Message ----------------------------------------------

    UserStats_Stats* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const UserStats_Stats& from);
    void MergeFrom(const UserStats_Stats& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 good = 1;
    inline bool has_good() const;
    inline void clear_good();
    static const int kGoodFieldNumber = 1;
    inline ::google::protobuf::uint32 good() const;
    inline void set_good(::google::protobuf::uint32 value);

    // optional uint32 late = 2;
    inline bool has_late() const;
    inline void clear_late();
    static const int kLateFieldNumber = 2;
    inline ::google::protobuf::uint32 late() const;
    inline void set_late(::google::protobuf::uint32 value);

    // optional uint32 lost = 3;
    inline bool has_lost() const;
    inline void clear_lost();
    static const int kLostFieldNumber = 3;
    inline ::google::protobuf::uint32 lost() const;
    inline void set_lost(::google::protobuf::uint32 value);

    // optional uint32 resync = 4;
    inline bool has_resync() const;
    inline void clear_resync();
    static const int kResyncFieldNumber = 4;
    inline ::google::protobuf::uint32 resync() const;
    inline void set_resync(::google::protobuf::uint32 value);

    // @@protoc_insertion_point(class_scope:MumbleProto.UserStats.Stats)
  private:
    inline void set_has_good();
    inline void clear_has_good();
    inline void set_has_late();
    inline void clear_has_late();
    inline void set_has_lost();
    inline void clear_has_lost();
    inline void set_has_resync();
    inline void clear_has_resync();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 good_;
    ::google::protobuf::uint32 late_;
    ::google::protobuf::uint32 lost_;
    ::google::protobuf::uint32 resync_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static UserStats_Stats* default_instance_;
  };
// -------------------------------------------------------------------

  class UserStats : public ::google::protobuf::Message
  {
  public:
    UserStats();
    virtual ~UserStats();

    UserStats(const UserStats& from);

    inline UserStats& operator=(const UserStats& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const UserStats& default_instance();

    void Swap(UserStats* other);

    // implements Message ----------------------------------------------

    UserStats* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const UserStats& from);
    void MergeFrom(const UserStats& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    typedef UserStats_Stats Stats;

    // accessors -------------------------------------------------------

    // optional uint32 session = 1;
    inline bool has_session() const;
    inline void clear_session();
    static const int kSessionFieldNumber = 1;
    inline ::google::protobuf::uint32 session() const;
    inline void set_session(::google::protobuf::uint32 value);

    // optional bool stats_only = 2 [default = false];
    inline bool has_stats_only() const;
    inline void clear_stats_only();
    static const int kStatsOnlyFieldNumber = 2;
    inline bool stats_only() const;
    inline void set_stats_only(bool value);

    // repeated bytes certificates = 3;
    inline int certificates_size() const;
    inline void clear_certificates();
    static const int kCertificatesFieldNumber = 3;
    inline const ::std::string& certificates(int index) const;
    inline ::std::string* mutable_certificates(int index);
    inline void set_certificates(int index, const ::std::string& value);
    inline void set_certificates(int index, const char* value);
    inline void set_certificates(int index, const void* value, size_t size);
    inline ::std::string* add_certificates();
    inline void add_certificates(const ::std::string& value);
    inline void add_certificates(const char* value);
    inline void add_certificates(const void* value, size_t size);
    inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
    certificates() const;
    inline ::google::protobuf::RepeatedPtrField< ::std::string>*
    mutable_certificates();

    // optional .MumbleProto.UserStats.Stats from_client = 4;
    inline bool has_from_client() const;
    inline void clear_from_client();
    static const int kFromClientFieldNumber = 4;
    inline const ::MumbleProto::UserStats_Stats& from_client() const;
    inline ::MumbleProto::UserStats_Stats* mutable_from_client();
    inline ::MumbleProto::UserStats_Stats* release_from_client();
    inline void set_allocated_from_client(::MumbleProto::UserStats_Stats*
                                          from_client);

    // optional .MumbleProto.UserStats.Stats from_server = 5;
    inline bool has_from_server() const;
    inline void clear_from_server();
    static const int kFromServerFieldNumber = 5;
    inline const ::MumbleProto::UserStats_Stats& from_server() const;
    inline ::MumbleProto::UserStats_Stats* mutable_from_server();
    inline ::MumbleProto::UserStats_Stats* release_from_server();
    inline void set_allocated_from_server(::MumbleProto::UserStats_Stats*
                                          from_server);

    // optional uint32 udp_packets = 6;
    inline bool has_udp_packets() const;
    inline void clear_udp_packets();
    static const int kUdpPacketsFieldNumber = 6;
    inline ::google::protobuf::uint32 udp_packets() const;
    inline void set_udp_packets(::google::protobuf::uint32 value);

    // optional uint32 tcp_packets = 7;
    inline bool has_tcp_packets() const;
    inline void clear_tcp_packets();
    static const int kTcpPacketsFieldNumber = 7;
    inline ::google::protobuf::uint32 tcp_packets() const;
    inline void set_tcp_packets(::google::protobuf::uint32 value);

    // optional float udp_ping_avg = 8;
    inline bool has_udp_ping_avg() const;
    inline void clear_udp_ping_avg();
    static const int kUdpPingAvgFieldNumber = 8;
    inline float udp_ping_avg() const;
    inline void set_udp_ping_avg(float value);

    // optional float udp_ping_var = 9;
    inline bool has_udp_ping_var() const;
    inline void clear_udp_ping_var();
    static const int kUdpPingVarFieldNumber = 9;
    inline float udp_ping_var() const;
    inline void set_udp_ping_var(float value);

    // optional float tcp_ping_avg = 10;
    inline bool has_tcp_ping_avg() const;
    inline void clear_tcp_ping_avg();
    static const int kTcpPingAvgFieldNumber = 10;
    inline float tcp_ping_avg() const;
    inline void set_tcp_ping_avg(float value);

    // optional float tcp_ping_var = 11;
    inline bool has_tcp_ping_var() const;
    inline void clear_tcp_ping_var();
    static const int kTcpPingVarFieldNumber = 11;
    inline float tcp_ping_var() const;
    inline void set_tcp_ping_var(float value);

    // optional .MumbleProto.Version version = 12;
    inline bool has_version() const;
    inline void clear_version();
    static const int kVersionFieldNumber = 12;
    inline const ::MumbleProto::Version& version() const;
    inline ::MumbleProto::Version* mutable_version();
    inline ::MumbleProto::Version* release_version();
    inline void set_allocated_version(::MumbleProto::Version* version);

    // repeated int32 celt_versions = 13;
    inline int celt_versions_size() const;
    inline void clear_celt_versions();
    static const int kCeltVersionsFieldNumber = 13;
    inline ::google::protobuf::int32 celt_versions(int index) const;
    inline void set_celt_versions(int index, ::google::protobuf::int32 value);
    inline void add_celt_versions(::google::protobuf::int32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
    celt_versions() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
    mutable_celt_versions();

    // optional bytes address = 14;
    inline bool has_address() const;
    inline void clear_address();
    static const int kAddressFieldNumber = 14;
    inline const ::std::string& address() const;
    inline void set_address(const ::std::string& value);
    inline void set_address(const char* value);
    inline void set_address(const void* value, size_t size);
    inline ::std::string* mutable_address();
    inline ::std::string* release_address();
    inline void set_allocated_address(::std::string* address);

    // optional uint32 bandwidth = 15;
    inline bool has_bandwidth() const;
    inline void clear_bandwidth();
    static const int kBandwidthFieldNumber = 15;
    inline ::google::protobuf::uint32 bandwidth() const;
    inline void set_bandwidth(::google::protobuf::uint32 value);

    // optional uint32 onlinesecs = 16;
    inline bool has_onlinesecs() const;
    inline void clear_onlinesecs();
    static const int kOnlinesecsFieldNumber = 16;
    inline ::google::protobuf::uint32 onlinesecs() const;
    inline void set_onlinesecs(::google::protobuf::uint32 value);

    // optional uint32 idlesecs = 17;
    inline bool has_idlesecs() const;
    inline void clear_idlesecs();
    static const int kIdlesecsFieldNumber = 17;
    inline ::google::protobuf::uint32 idlesecs() const;
    inline void set_idlesecs(::google::protobuf::uint32 value);

    // optional bool strong_certificate = 18 [default = false];
    inline bool has_strong_certificate() const;
    inline void clear_strong_certificate();
    static const int kStrongCertificateFieldNumber = 18;
    inline bool strong_certificate() const;
    inline void set_strong_certificate(bool value);

    // optional bool opus = 19 [default = false];
    inline bool has_opus() const;
    inline void clear_opus();
    static const int kOpusFieldNumber = 19;
    inline bool opus() const;
    inline void set_opus(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.UserStats)
  private:
    inline void set_has_session();
    inline void clear_has_session();
    inline void set_has_stats_only();
    inline void clear_has_stats_only();
    inline void set_has_from_client();
    inline void clear_has_from_client();
    inline void set_has_from_server();
    inline void clear_has_from_server();
    inline void set_has_udp_packets();
    inline void clear_has_udp_packets();
    inline void set_has_tcp_packets();
    inline void clear_has_tcp_packets();
    inline void set_has_udp_ping_avg();
    inline void clear_has_udp_ping_avg();
    inline void set_has_udp_ping_var();
    inline void clear_has_udp_ping_var();
    inline void set_has_tcp_ping_avg();
    inline void clear_has_tcp_ping_avg();
    inline void set_has_tcp_ping_var();
    inline void clear_has_tcp_ping_var();
    inline void set_has_version();
    inline void clear_has_version();
    inline void set_has_address();
    inline void clear_has_address();
    inline void set_has_bandwidth();
    inline void clear_has_bandwidth();
    inline void set_has_onlinesecs();
    inline void clear_has_onlinesecs();
    inline void set_has_idlesecs();
    inline void clear_has_idlesecs();
    inline void set_has_strong_certificate();
    inline void clear_has_strong_certificate();
    inline void set_has_opus();
    inline void clear_has_opus();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::std::string> certificates_;
    ::google::protobuf::uint32 session_;
    ::google::protobuf::uint32 udp_packets_;
    ::MumbleProto::UserStats_Stats* from_client_;
    ::MumbleProto::UserStats_Stats* from_server_;
    ::google::protobuf::uint32 tcp_packets_;
    float udp_ping_avg_;
    float udp_ping_var_;
    float tcp_ping_avg_;
    ::MumbleProto::Version* version_;
    float tcp_ping_var_;
    bool stats_only_;
    bool strong_certificate_;
    bool opus_;
    ::google::protobuf::RepeatedField< ::google::protobuf::int32 > celt_versions_;
    ::std::string* address_;
    ::google::protobuf::uint32 bandwidth_;
    ::google::protobuf::uint32 onlinesecs_;
    ::google::protobuf::uint32 idlesecs_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static UserStats* default_instance_;
  };
// -------------------------------------------------------------------

  class RequestBlob : public ::google::protobuf::Message
  {
  public:
    RequestBlob();
    virtual ~RequestBlob();

    RequestBlob(const RequestBlob& from);

    inline RequestBlob& operator=(const RequestBlob& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const RequestBlob& default_instance();

    void Swap(RequestBlob* other);

    // implements Message ----------------------------------------------

    RequestBlob* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const RequestBlob& from);
    void MergeFrom(const RequestBlob& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated uint32 session_texture = 1;
    inline int session_texture_size() const;
    inline void clear_session_texture();
    static const int kSessionTextureFieldNumber = 1;
    inline ::google::protobuf::uint32 session_texture(int index) const;
    inline void set_session_texture(int index, ::google::protobuf::uint32 value);
    inline void add_session_texture(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    session_texture() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_session_texture();

    // repeated uint32 session_comment = 2;
    inline int session_comment_size() const;
    inline void clear_session_comment();
    static const int kSessionCommentFieldNumber = 2;
    inline ::google::protobuf::uint32 session_comment(int index) const;
    inline void set_session_comment(int index, ::google::protobuf::uint32 value);
    inline void add_session_comment(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    session_comment() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_session_comment();

    // repeated uint32 channel_description = 3;
    inline int channel_description_size() const;
    inline void clear_channel_description();
    static const int kChannelDescriptionFieldNumber = 3;
    inline ::google::protobuf::uint32 channel_description(int index) const;
    inline void set_channel_description(int index,
                                        ::google::protobuf::uint32 value);
    inline void add_channel_description(::google::protobuf::uint32 value);
    inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
    channel_description() const;
    inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
    mutable_channel_description();

    // @@protoc_insertion_point(class_scope:MumbleProto.RequestBlob)
  private:

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >
    session_texture_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >
    session_comment_;
    ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >
    channel_description_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static RequestBlob* default_instance_;
  };
// -------------------------------------------------------------------

  class ServerConfig : public ::google::protobuf::Message
  {
  public:
    ServerConfig();
    virtual ~ServerConfig();

    ServerConfig(const ServerConfig& from);

    inline ServerConfig& operator=(const ServerConfig& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ServerConfig& default_instance();

    void Swap(ServerConfig* other);

    // implements Message ----------------------------------------------

    ServerConfig* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ServerConfig& from);
    void MergeFrom(const ServerConfig& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 max_bandwidth = 1;
    inline bool has_max_bandwidth() const;
    inline void clear_max_bandwidth();
    static const int kMaxBandwidthFieldNumber = 1;
    inline ::google::protobuf::uint32 max_bandwidth() const;
    inline void set_max_bandwidth(::google::protobuf::uint32 value);

    // optional string welcome_text = 2;
    inline bool has_welcome_text() const;
    inline void clear_welcome_text();
    static const int kWelcomeTextFieldNumber = 2;
    inline const ::std::string& welcome_text() const;
    inline void set_welcome_text(const ::std::string& value);
    inline void set_welcome_text(const char* value);
    inline void set_welcome_text(const char* value, size_t size);
    inline ::std::string* mutable_welcome_text();
    inline ::std::string* release_welcome_text();
    inline void set_allocated_welcome_text(::std::string* welcome_text);

    // optional bool allow_html = 3;
    inline bool has_allow_html() const;
    inline void clear_allow_html();
    static const int kAllowHtmlFieldNumber = 3;
    inline bool allow_html() const;
    inline void set_allow_html(bool value);

    // optional uint32 message_length = 4;
    inline bool has_message_length() const;
    inline void clear_message_length();
    static const int kMessageLengthFieldNumber = 4;
    inline ::google::protobuf::uint32 message_length() const;
    inline void set_message_length(::google::protobuf::uint32 value);

    // optional uint32 image_message_length = 5;
    inline bool has_image_message_length() const;
    inline void clear_image_message_length();
    static const int kImageMessageLengthFieldNumber = 5;
    inline ::google::protobuf::uint32 image_message_length() const;
    inline void set_image_message_length(::google::protobuf::uint32 value);

    // optional uint32 max_users = 6;
    inline bool has_max_users() const;
    inline void clear_max_users();
    static const int kMaxUsersFieldNumber = 6;
    inline ::google::protobuf::uint32 max_users() const;
    inline void set_max_users(::google::protobuf::uint32 value);

    // @@protoc_insertion_point(class_scope:MumbleProto.ServerConfig)
  private:
    inline void set_has_max_bandwidth();
    inline void clear_has_max_bandwidth();
    inline void set_has_welcome_text();
    inline void clear_has_welcome_text();
    inline void set_has_allow_html();
    inline void clear_has_allow_html();
    inline void set_has_message_length();
    inline void clear_has_message_length();
    inline void set_has_image_message_length();
    inline void clear_has_image_message_length();
    inline void set_has_max_users();
    inline void clear_has_max_users();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::std::string* welcome_text_;
    ::google::protobuf::uint32 max_bandwidth_;
    bool allow_html_;
    ::google::protobuf::uint32 message_length_;
    ::google::protobuf::uint32 image_message_length_;
    ::google::protobuf::uint32 max_users_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static ServerConfig* default_instance_;
  };
// -------------------------------------------------------------------

  class SuggestConfig : public ::google::protobuf::Message
  {
  public:
    SuggestConfig();
    virtual ~SuggestConfig();

    SuggestConfig(const SuggestConfig& from);

    inline SuggestConfig& operator=(const SuggestConfig& from)
    {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
      return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const SuggestConfig& default_instance();

    void Swap(SuggestConfig* other);

    // implements Message ----------------------------------------------

    SuggestConfig* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const SuggestConfig& from);
    void MergeFrom(const SuggestConfig& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
      return _cached_size_;
    }
  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
  public:
    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 version = 1;
    inline bool has_version() const;
    inline void clear_version();
    static const int kVersionFieldNumber = 1;
    inline ::google::protobuf::uint32 version() const;
    inline void set_version(::google::protobuf::uint32 value);

    // optional bool positional = 2;
    inline bool has_positional() const;
    inline void clear_positional();
    static const int kPositionalFieldNumber = 2;
    inline bool positional() const;
    inline void set_positional(bool value);

    // optional bool push_to_talk = 3;
    inline bool has_push_to_talk() const;
    inline void clear_push_to_talk();
    static const int kPushToTalkFieldNumber = 3;
    inline bool push_to_talk() const;
    inline void set_push_to_talk(bool value);

    // @@protoc_insertion_point(class_scope:MumbleProto.SuggestConfig)
  private:
    inline void set_has_version();
    inline void clear_has_version();
    inline void set_has_positional();
    inline void clear_has_positional();
    inline void set_has_push_to_talk();
    inline void clear_has_push_to_talk();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 version_;
    bool positional_;
    bool push_to_talk_;
    friend void  protobuf_AddDesc_Mumble_2eproto();
    friend void protobuf_AssignDesc_Mumble_2eproto();
    friend void protobuf_ShutdownFile_Mumble_2eproto();

    void InitAsDefaultInstance();
    static SuggestConfig* default_instance_;
  };
// ===================================================================


// ===================================================================

// Version

// optional uint32 version = 1;
  inline bool Version::has_version() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void Version::set_has_version()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void Version::clear_has_version()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void Version::clear_version()
  {
    version_ = 0u;
    clear_has_version();
  }
  inline ::google::protobuf::uint32 Version::version() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Version.version)
    return version_;
  }
  inline void Version::set_version(::google::protobuf::uint32 value)
  {
    set_has_version();
    version_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Version.version)
  }

// optional string release = 2;
  inline bool Version::has_release() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void Version::set_has_release()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void Version::clear_has_release()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void Version::clear_release()
  {
    if (release_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        release_->clear();
      }
    clear_has_release();
  }
  inline const ::std::string& Version::release() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Version.release)
    return *release_;
  }
  inline void Version::set_release(const ::std::string& value)
  {
    set_has_release();
    if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        release_ = new ::std::string;
      }
    release_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.Version.release)
  }
  inline void Version::set_release(const char* value)
  {
    set_has_release();
    if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        release_ = new ::std::string;
      }
    release_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.Version.release)
  }
  inline void Version::set_release(const char* value, size_t size)
  {
    set_has_release();
    if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        release_ = new ::std::string;
      }
    release_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.release)
  }
  inline ::std::string* Version::mutable_release()
  {
    set_has_release();
    if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        release_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.Version.release)
    return release_;
  }
  inline ::std::string* Version::release_release()
  {
    clear_has_release();
    if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = release_;
        release_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void Version::set_allocated_release(::std::string* release)
  {
    if (release_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete release_;
      }
    if (release)
      {
        set_has_release();
        release_ = release;
      }
    else
      {
        clear_has_release();
        release_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.release)
  }

// optional string os = 3;
  inline bool Version::has_os() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void Version::set_has_os()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void Version::clear_has_os()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void Version::clear_os()
  {
    if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_->clear();
      }
    clear_has_os();
  }
  inline const ::std::string& Version::os() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Version.os)
    return *os_;
  }
  inline void Version::set_os(const ::std::string& value)
  {
    set_has_os();
    if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_ = new ::std::string;
      }
    os_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.Version.os)
  }
  inline void Version::set_os(const char* value)
  {
    set_has_os();
    if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_ = new ::std::string;
      }
    os_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.Version.os)
  }
  inline void Version::set_os(const char* value, size_t size)
  {
    set_has_os();
    if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_ = new ::std::string;
      }
    os_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.os)
  }
  inline ::std::string* Version::mutable_os()
  {
    set_has_os();
    if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.Version.os)
    return os_;
  }
  inline ::std::string* Version::release_os()
  {
    clear_has_os();
    if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = os_;
        os_ = const_cast< ::std::string*>
              (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void Version::set_allocated_os(::std::string* os)
  {
    if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete os_;
      }
    if (os)
      {
        set_has_os();
        os_ = os;
      }
    else
      {
        clear_has_os();
        os_ = const_cast< ::std::string*>
              (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.os)
  }

// optional string os_version = 4;
  inline bool Version::has_os_version() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void Version::set_has_os_version()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void Version::clear_has_os_version()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void Version::clear_os_version()
  {
    if (os_version_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_version_->clear();
      }
    clear_has_os_version();
  }
  inline const ::std::string& Version::os_version() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Version.os_version)
    return *os_version_;
  }
  inline void Version::set_os_version(const ::std::string& value)
  {
    set_has_os_version();
    if (os_version_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_version_ = new ::std::string;
      }
    os_version_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.Version.os_version)
  }
  inline void Version::set_os_version(const char* value)
  {
    set_has_os_version();
    if (os_version_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_version_ = new ::std::string;
      }
    os_version_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.Version.os_version)
  }
  inline void Version::set_os_version(const char* value, size_t size)
  {
    set_has_os_version();
    if (os_version_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_version_ = new ::std::string;
      }
    os_version_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.os_version)
  }
  inline ::std::string* Version::mutable_os_version()
  {
    set_has_os_version();
    if (os_version_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        os_version_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.Version.os_version)
    return os_version_;
  }
  inline ::std::string* Version::release_os_version()
  {
    clear_has_os_version();
    if (os_version_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = os_version_;
        os_version_ = const_cast< ::std::string*>
                      (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void Version::set_allocated_os_version(::std::string* os_version)
  {
    if (os_version_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete os_version_;
      }
    if (os_version)
      {
        set_has_os_version();
        os_version_ = os_version;
      }
    else
      {
        clear_has_os_version();
        os_version_ = const_cast< ::std::string*>
                      (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.os_version)
  }

// -------------------------------------------------------------------

// UDPTunnel

// required bytes packet = 1;
  inline bool UDPTunnel::has_packet() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void UDPTunnel::set_has_packet()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void UDPTunnel::clear_has_packet()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void UDPTunnel::clear_packet()
  {
    if (packet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        packet_->clear();
      }
    clear_has_packet();
  }
  inline const ::std::string& UDPTunnel::packet() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UDPTunnel.packet)
    return *packet_;
  }
  inline void UDPTunnel::set_packet(const ::std::string& value)
  {
    set_has_packet();
    if (packet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        packet_ = new ::std::string;
      }
    packet_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UDPTunnel.packet)
  }
  inline void UDPTunnel::set_packet(const char* value)
  {
    set_has_packet();
    if (packet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        packet_ = new ::std::string;
      }
    packet_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UDPTunnel.packet)
  }
  inline void UDPTunnel::set_packet(const void* value, size_t size)
  {
    set_has_packet();
    if (packet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        packet_ = new ::std::string;
      }
    packet_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UDPTunnel.packet)
  }
  inline ::std::string* UDPTunnel::mutable_packet()
  {
    set_has_packet();
    if (packet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        packet_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UDPTunnel.packet)
    return packet_;
  }
  inline ::std::string* UDPTunnel::release_packet()
  {
    clear_has_packet();
    if (packet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = packet_;
        packet_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UDPTunnel::set_allocated_packet(::std::string* packet)
  {
    if (packet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete packet_;
      }
    if (packet)
      {
        set_has_packet();
        packet_ = packet;
      }
    else
      {
        clear_has_packet();
        packet_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UDPTunnel.packet)
  }

// -------------------------------------------------------------------

// Authenticate

// optional string username = 1;
  inline bool Authenticate::has_username() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void Authenticate::set_has_username()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void Authenticate::clear_has_username()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void Authenticate::clear_username()
  {
    if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        username_->clear();
      }
    clear_has_username();
  }
  inline const ::std::string& Authenticate::username() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.username)
    return *username_;
  }
  inline void Authenticate::set_username(const ::std::string& value)
  {
    set_has_username();
    if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        username_ = new ::std::string;
      }
    username_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.username)
  }
  inline void Authenticate::set_username(const char* value)
  {
    set_has_username();
    if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        username_ = new ::std::string;
      }
    username_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.username)
  }
  inline void Authenticate::set_username(const char* value, size_t size)
  {
    set_has_username();
    if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        username_ = new ::std::string;
      }
    username_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.username)
  }
  inline ::std::string* Authenticate::mutable_username()
  {
    set_has_username();
    if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        username_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.username)
    return username_;
  }
  inline ::std::string* Authenticate::release_username()
  {
    clear_has_username();
    if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = username_;
        username_ = const_cast< ::std::string*>
                    (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void Authenticate::set_allocated_username(::std::string* username)
  {
    if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete username_;
      }
    if (username)
      {
        set_has_username();
        username_ = username;
      }
    else
      {
        clear_has_username();
        username_ = const_cast< ::std::string*>
                    (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.Authenticate.username)
  }

// optional string password = 2;
  inline bool Authenticate::has_password() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void Authenticate::set_has_password()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void Authenticate::clear_has_password()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void Authenticate::clear_password()
  {
    if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        password_->clear();
      }
    clear_has_password();
  }
  inline const ::std::string& Authenticate::password() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.password)
    return *password_;
  }
  inline void Authenticate::set_password(const ::std::string& value)
  {
    set_has_password();
    if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        password_ = new ::std::string;
      }
    password_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.password)
  }
  inline void Authenticate::set_password(const char* value)
  {
    set_has_password();
    if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        password_ = new ::std::string;
      }
    password_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.password)
  }
  inline void Authenticate::set_password(const char* value, size_t size)
  {
    set_has_password();
    if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        password_ = new ::std::string;
      }
    password_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.password)
  }
  inline ::std::string* Authenticate::mutable_password()
  {
    set_has_password();
    if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        password_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.password)
    return password_;
  }
  inline ::std::string* Authenticate::release_password()
  {
    clear_has_password();
    if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = password_;
        password_ = const_cast< ::std::string*>
                    (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void Authenticate::set_allocated_password(::std::string* password)
  {
    if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete password_;
      }
    if (password)
      {
        set_has_password();
        password_ = password;
      }
    else
      {
        clear_has_password();
        password_ = const_cast< ::std::string*>
                    (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.Authenticate.password)
  }

// repeated string tokens = 3;
  inline int Authenticate::tokens_size() const
  {
    return tokens_.size();
  }
  inline void Authenticate::clear_tokens()
  {
    tokens_.Clear();
  }
  inline const ::std::string& Authenticate::tokens(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.tokens)
    return tokens_.Get(index);
  }
  inline ::std::string* Authenticate::mutable_tokens(int index)
  {
    // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.tokens)
    return tokens_.Mutable(index);
  }
  inline void Authenticate::set_tokens(int index, const ::std::string& value)
  {
    // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.tokens)
    tokens_.Mutable(index)->assign(value);
  }
  inline void Authenticate::set_tokens(int index, const char* value)
  {
    tokens_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.tokens)
  }
  inline void Authenticate::set_tokens(int index, const char* value, size_t size)
  {
    tokens_.Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.tokens)
  }
  inline ::std::string* Authenticate::add_tokens()
  {
    return tokens_.Add();
  }
  inline void Authenticate::add_tokens(const ::std::string& value)
  {
    tokens_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.tokens)
  }
  inline void Authenticate::add_tokens(const char* value)
  {
    tokens_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:MumbleProto.Authenticate.tokens)
  }
  inline void Authenticate::add_tokens(const char* value, size_t size)
  {
    tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:MumbleProto.Authenticate.tokens)
  }
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
  Authenticate::tokens() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.Authenticate.tokens)
    return tokens_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::std::string>*
  Authenticate::mutable_tokens()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.Authenticate.tokens)
    return &tokens_;
  }

// repeated int32 celt_versions = 4;
  inline int Authenticate::celt_versions_size() const
  {
    return celt_versions_.size();
  }
  inline void Authenticate::clear_celt_versions()
  {
    celt_versions_.Clear();
  }
  inline ::google::protobuf::int32 Authenticate::celt_versions(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.celt_versions)
    return celt_versions_.Get(index);
  }
  inline void Authenticate::set_celt_versions(int index,
      ::google::protobuf::int32 value)
  {
    celt_versions_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.celt_versions)
  }
  inline void Authenticate::add_celt_versions(::google::protobuf::int32 value)
  {
    celt_versions_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.celt_versions)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
  Authenticate::celt_versions() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.Authenticate.celt_versions)
    return celt_versions_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
  Authenticate::mutable_celt_versions()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.Authenticate.celt_versions)
    return &celt_versions_;
  }

// optional bool opus = 5 [default = false];
  inline bool Authenticate::has_opus() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void Authenticate::set_has_opus()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void Authenticate::clear_has_opus()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void Authenticate::clear_opus()
  {
    opus_ = false;
    clear_has_opus();
  }
  inline bool Authenticate::opus() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.opus)
    return opus_;
  }
  inline void Authenticate::set_opus(bool value)
  {
    set_has_opus();
    opus_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.opus)
  }

// -------------------------------------------------------------------

// Ping

// optional uint64 timestamp = 1;
  inline bool Ping::has_timestamp() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void Ping::set_has_timestamp()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void Ping::clear_has_timestamp()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void Ping::clear_timestamp()
  {
    timestamp_ = GOOGLE_ULONGLONG(0);
    clear_has_timestamp();
  }
  inline ::google::protobuf::uint64 Ping::timestamp() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.timestamp)
    return timestamp_;
  }
  inline void Ping::set_timestamp(::google::protobuf::uint64 value)
  {
    set_has_timestamp();
    timestamp_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.timestamp)
  }

// optional uint32 good = 2;
  inline bool Ping::has_good() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void Ping::set_has_good()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void Ping::clear_has_good()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void Ping::clear_good()
  {
    good_ = 0u;
    clear_has_good();
  }
  inline ::google::protobuf::uint32 Ping::good() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.good)
    return good_;
  }
  inline void Ping::set_good(::google::protobuf::uint32 value)
  {
    set_has_good();
    good_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.good)
  }

// optional uint32 late = 3;
  inline bool Ping::has_late() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void Ping::set_has_late()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void Ping::clear_has_late()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void Ping::clear_late()
  {
    late_ = 0u;
    clear_has_late();
  }
  inline ::google::protobuf::uint32 Ping::late() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.late)
    return late_;
  }
  inline void Ping::set_late(::google::protobuf::uint32 value)
  {
    set_has_late();
    late_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.late)
  }

// optional uint32 lost = 4;
  inline bool Ping::has_lost() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void Ping::set_has_lost()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void Ping::clear_has_lost()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void Ping::clear_lost()
  {
    lost_ = 0u;
    clear_has_lost();
  }
  inline ::google::protobuf::uint32 Ping::lost() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.lost)
    return lost_;
  }
  inline void Ping::set_lost(::google::protobuf::uint32 value)
  {
    set_has_lost();
    lost_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.lost)
  }

// optional uint32 resync = 5;
  inline bool Ping::has_resync() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void Ping::set_has_resync()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void Ping::clear_has_resync()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void Ping::clear_resync()
  {
    resync_ = 0u;
    clear_has_resync();
  }
  inline ::google::protobuf::uint32 Ping::resync() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.resync)
    return resync_;
  }
  inline void Ping::set_resync(::google::protobuf::uint32 value)
  {
    set_has_resync();
    resync_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.resync)
  }

// optional uint32 udp_packets = 6;
  inline bool Ping::has_udp_packets() const
  {
    return (_has_bits_[0] & 0x00000020u) != 0;
  }
  inline void Ping::set_has_udp_packets()
  {
    _has_bits_[0] |= 0x00000020u;
  }
  inline void Ping::clear_has_udp_packets()
  {
    _has_bits_[0] &= ~0x00000020u;
  }
  inline void Ping::clear_udp_packets()
  {
    udp_packets_ = 0u;
    clear_has_udp_packets();
  }
  inline ::google::protobuf::uint32 Ping::udp_packets() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_packets)
    return udp_packets_;
  }
  inline void Ping::set_udp_packets(::google::protobuf::uint32 value)
  {
    set_has_udp_packets();
    udp_packets_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_packets)
  }

// optional uint32 tcp_packets = 7;
  inline bool Ping::has_tcp_packets() const
  {
    return (_has_bits_[0] & 0x00000040u) != 0;
  }
  inline void Ping::set_has_tcp_packets()
  {
    _has_bits_[0] |= 0x00000040u;
  }
  inline void Ping::clear_has_tcp_packets()
  {
    _has_bits_[0] &= ~0x00000040u;
  }
  inline void Ping::clear_tcp_packets()
  {
    tcp_packets_ = 0u;
    clear_has_tcp_packets();
  }
  inline ::google::protobuf::uint32 Ping::tcp_packets() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_packets)
    return tcp_packets_;
  }
  inline void Ping::set_tcp_packets(::google::protobuf::uint32 value)
  {
    set_has_tcp_packets();
    tcp_packets_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_packets)
  }

// optional float udp_ping_avg = 8;
  inline bool Ping::has_udp_ping_avg() const
  {
    return (_has_bits_[0] & 0x00000080u) != 0;
  }
  inline void Ping::set_has_udp_ping_avg()
  {
    _has_bits_[0] |= 0x00000080u;
  }
  inline void Ping::clear_has_udp_ping_avg()
  {
    _has_bits_[0] &= ~0x00000080u;
  }
  inline void Ping::clear_udp_ping_avg()
  {
    udp_ping_avg_ = 0;
    clear_has_udp_ping_avg();
  }
  inline float Ping::udp_ping_avg() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_ping_avg)
    return udp_ping_avg_;
  }
  inline void Ping::set_udp_ping_avg(float value)
  {
    set_has_udp_ping_avg();
    udp_ping_avg_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_ping_avg)
  }

// optional float udp_ping_var = 9;
  inline bool Ping::has_udp_ping_var() const
  {
    return (_has_bits_[0] & 0x00000100u) != 0;
  }
  inline void Ping::set_has_udp_ping_var()
  {
    _has_bits_[0] |= 0x00000100u;
  }
  inline void Ping::clear_has_udp_ping_var()
  {
    _has_bits_[0] &= ~0x00000100u;
  }
  inline void Ping::clear_udp_ping_var()
  {
    udp_ping_var_ = 0;
    clear_has_udp_ping_var();
  }
  inline float Ping::udp_ping_var() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_ping_var)
    return udp_ping_var_;
  }
  inline void Ping::set_udp_ping_var(float value)
  {
    set_has_udp_ping_var();
    udp_ping_var_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_ping_var)
  }

// optional float tcp_ping_avg = 10;
  inline bool Ping::has_tcp_ping_avg() const
  {
    return (_has_bits_[0] & 0x00000200u) != 0;
  }
  inline void Ping::set_has_tcp_ping_avg()
  {
    _has_bits_[0] |= 0x00000200u;
  }
  inline void Ping::clear_has_tcp_ping_avg()
  {
    _has_bits_[0] &= ~0x00000200u;
  }
  inline void Ping::clear_tcp_ping_avg()
  {
    tcp_ping_avg_ = 0;
    clear_has_tcp_ping_avg();
  }
  inline float Ping::tcp_ping_avg() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_ping_avg)
    return tcp_ping_avg_;
  }
  inline void Ping::set_tcp_ping_avg(float value)
  {
    set_has_tcp_ping_avg();
    tcp_ping_avg_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_ping_avg)
  }

// optional float tcp_ping_var = 11;
  inline bool Ping::has_tcp_ping_var() const
  {
    return (_has_bits_[0] & 0x00000400u) != 0;
  }
  inline void Ping::set_has_tcp_ping_var()
  {
    _has_bits_[0] |= 0x00000400u;
  }
  inline void Ping::clear_has_tcp_ping_var()
  {
    _has_bits_[0] &= ~0x00000400u;
  }
  inline void Ping::clear_tcp_ping_var()
  {
    tcp_ping_var_ = 0;
    clear_has_tcp_ping_var();
  }
  inline float Ping::tcp_ping_var() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_ping_var)
    return tcp_ping_var_;
  }
  inline void Ping::set_tcp_ping_var(float value)
  {
    set_has_tcp_ping_var();
    tcp_ping_var_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_ping_var)
  }

// -------------------------------------------------------------------

// Reject

// optional .MumbleProto.Reject.RejectType type = 1;
  inline bool Reject::has_type() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void Reject::set_has_type()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void Reject::clear_has_type()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void Reject::clear_type()
  {
    type_ = 0;
    clear_has_type();
  }
  inline ::MumbleProto::Reject_RejectType Reject::type() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Reject.type)
    return static_cast< ::MumbleProto::Reject_RejectType >(type_);
  }
  inline void Reject::set_type(::MumbleProto::Reject_RejectType value)
  {
    assert(::MumbleProto::Reject_RejectType_IsValid(value));
    set_has_type();
    type_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.Reject.type)
  }

// optional string reason = 2;
  inline bool Reject::has_reason() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void Reject::set_has_reason()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void Reject::clear_has_reason()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void Reject::clear_reason()
  {
    if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_->clear();
      }
    clear_has_reason();
  }
  inline const ::std::string& Reject::reason() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.Reject.reason)
    return *reason_;
  }
  inline void Reject::set_reason(const ::std::string& value)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.Reject.reason)
  }
  inline void Reject::set_reason(const char* value)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.Reject.reason)
  }
  inline void Reject::set_reason(const char* value, size_t size)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.Reject.reason)
  }
  inline ::std::string* Reject::mutable_reason()
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.Reject.reason)
    return reason_;
  }
  inline ::std::string* Reject::release_reason()
  {
    clear_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = reason_;
        reason_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void Reject::set_allocated_reason(::std::string* reason)
  {
    if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete reason_;
      }
    if (reason)
      {
        set_has_reason();
        reason_ = reason;
      }
    else
      {
        clear_has_reason();
        reason_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.Reject.reason)
  }

// -------------------------------------------------------------------

// ServerSync

// optional uint32 session = 1;
  inline bool ServerSync::has_session() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void ServerSync::set_has_session()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void ServerSync::clear_has_session()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void ServerSync::clear_session()
  {
    session_ = 0u;
    clear_has_session();
  }
  inline ::google::protobuf::uint32 ServerSync::session() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.session)
    return session_;
  }
  inline void ServerSync::set_session(::google::protobuf::uint32 value)
  {
    set_has_session();
    session_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.session)
  }

// optional uint32 max_bandwidth = 2;
  inline bool ServerSync::has_max_bandwidth() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void ServerSync::set_has_max_bandwidth()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void ServerSync::clear_has_max_bandwidth()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void ServerSync::clear_max_bandwidth()
  {
    max_bandwidth_ = 0u;
    clear_has_max_bandwidth();
  }
  inline ::google::protobuf::uint32 ServerSync::max_bandwidth() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.max_bandwidth)
    return max_bandwidth_;
  }
  inline void ServerSync::set_max_bandwidth(::google::protobuf::uint32 value)
  {
    set_has_max_bandwidth();
    max_bandwidth_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.max_bandwidth)
  }

// optional string welcome_text = 3;
  inline bool ServerSync::has_welcome_text() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void ServerSync::set_has_welcome_text()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void ServerSync::clear_has_welcome_text()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void ServerSync::clear_welcome_text()
  {
    if (welcome_text_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_->clear();
      }
    clear_has_welcome_text();
  }
  inline const ::std::string& ServerSync::welcome_text() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.welcome_text)
    return *welcome_text_;
  }
  inline void ServerSync::set_welcome_text(const ::std::string& value)
  {
    set_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_ = new ::std::string;
      }
    welcome_text_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.welcome_text)
  }
  inline void ServerSync::set_welcome_text(const char* value)
  {
    set_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_ = new ::std::string;
      }
    welcome_text_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ServerSync.welcome_text)
  }
  inline void ServerSync::set_welcome_text(const char* value, size_t size)
  {
    set_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_ = new ::std::string;
      }
    welcome_text_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ServerSync.welcome_text)
  }
  inline ::std::string* ServerSync::mutable_welcome_text()
  {
    set_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ServerSync.welcome_text)
    return welcome_text_;
  }
  inline ::std::string* ServerSync::release_welcome_text()
  {
    clear_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = welcome_text_;
        welcome_text_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ServerSync::set_allocated_welcome_text(::std::string* welcome_text)
  {
    if (welcome_text_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete welcome_text_;
      }
    if (welcome_text)
      {
        set_has_welcome_text();
        welcome_text_ = welcome_text;
      }
    else
      {
        clear_has_welcome_text();
        welcome_text_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ServerSync.welcome_text)
  }

// optional uint64 permissions = 4;
  inline bool ServerSync::has_permissions() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void ServerSync::set_has_permissions()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void ServerSync::clear_has_permissions()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void ServerSync::clear_permissions()
  {
    permissions_ = GOOGLE_ULONGLONG(0);
    clear_has_permissions();
  }
  inline ::google::protobuf::uint64 ServerSync::permissions() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.permissions)
    return permissions_;
  }
  inline void ServerSync::set_permissions(::google::protobuf::uint64 value)
  {
    set_has_permissions();
    permissions_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.permissions)
  }

// -------------------------------------------------------------------

// ChannelRemove

// required uint32 channel_id = 1;
  inline bool ChannelRemove::has_channel_id() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void ChannelRemove::set_has_channel_id()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void ChannelRemove::clear_has_channel_id()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void ChannelRemove::clear_channel_id()
  {
    channel_id_ = 0u;
    clear_has_channel_id();
  }
  inline ::google::protobuf::uint32 ChannelRemove::channel_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelRemove.channel_id)
    return channel_id_;
  }
  inline void ChannelRemove::set_channel_id(::google::protobuf::uint32 value)
  {
    set_has_channel_id();
    channel_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelRemove.channel_id)
  }

// -------------------------------------------------------------------

// ChannelState

// optional uint32 channel_id = 1;
  inline bool ChannelState::has_channel_id() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void ChannelState::set_has_channel_id()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void ChannelState::clear_has_channel_id()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void ChannelState::clear_channel_id()
  {
    channel_id_ = 0u;
    clear_has_channel_id();
  }
  inline ::google::protobuf::uint32 ChannelState::channel_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.channel_id)
    return channel_id_;
  }
  inline void ChannelState::set_channel_id(::google::protobuf::uint32 value)
  {
    set_has_channel_id();
    channel_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.channel_id)
  }

// optional uint32 parent = 2;
  inline bool ChannelState::has_parent() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void ChannelState::set_has_parent()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void ChannelState::clear_has_parent()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void ChannelState::clear_parent()
  {
    parent_ = 0u;
    clear_has_parent();
  }
  inline ::google::protobuf::uint32 ChannelState::parent() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.parent)
    return parent_;
  }
  inline void ChannelState::set_parent(::google::protobuf::uint32 value)
  {
    set_has_parent();
    parent_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.parent)
  }

// optional string name = 3;
  inline bool ChannelState::has_name() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void ChannelState::set_has_name()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void ChannelState::clear_has_name()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void ChannelState::clear_name()
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_->clear();
      }
    clear_has_name();
  }
  inline const ::std::string& ChannelState::name() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.name)
    return *name_;
  }
  inline void ChannelState::set_name(const ::std::string& value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.name)
  }
  inline void ChannelState::set_name(const char* value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.name)
  }
  inline void ChannelState::set_name(const char* value, size_t size)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.name)
  }
  inline ::std::string* ChannelState::mutable_name()
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.name)
    return name_;
  }
  inline ::std::string* ChannelState::release_name()
  {
    clear_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = name_;
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ChannelState::set_allocated_name(::std::string* name)
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete name_;
      }
    if (name)
      {
        set_has_name();
        name_ = name;
      }
    else
      {
        clear_has_name();
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.name)
  }

// repeated uint32 links = 4;
  inline int ChannelState::links_size() const
  {
    return links_.size();
  }
  inline void ChannelState::clear_links()
  {
    links_.Clear();
  }
  inline ::google::protobuf::uint32 ChannelState::links(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links)
    return links_.Get(index);
  }
  inline void ChannelState::set_links(int index,
                                      ::google::protobuf::uint32 value)
  {
    links_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links)
  }
  inline void ChannelState::add_links(::google::protobuf::uint32 value)
  {
    links_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  ChannelState::links() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links)
    return links_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  ChannelState::mutable_links()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links)
    return &links_;
  }

// optional string description = 5;
  inline bool ChannelState::has_description() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void ChannelState::set_has_description()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void ChannelState::clear_has_description()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void ChannelState::clear_description()
  {
    if (description_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_->clear();
      }
    clear_has_description();
  }
  inline const ::std::string& ChannelState::description() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.description)
    return *description_;
  }
  inline void ChannelState::set_description(const ::std::string& value)
  {
    set_has_description();
    if (description_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_ = new ::std::string;
      }
    description_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.description)
  }
  inline void ChannelState::set_description(const char* value)
  {
    set_has_description();
    if (description_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_ = new ::std::string;
      }
    description_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.description)
  }
  inline void ChannelState::set_description(const char* value, size_t size)
  {
    set_has_description();
    if (description_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_ = new ::std::string;
      }
    description_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.description)
  }
  inline ::std::string* ChannelState::mutable_description()
  {
    set_has_description();
    if (description_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.description)
    return description_;
  }
  inline ::std::string* ChannelState::release_description()
  {
    clear_has_description();
    if (description_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = description_;
        description_ = const_cast< ::std::string*>
                       (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ChannelState::set_allocated_description(::std::string* description)
  {
    if (description_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete description_;
      }
    if (description)
      {
        set_has_description();
        description_ = description;
      }
    else
      {
        clear_has_description();
        description_ = const_cast< ::std::string*>
                       (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.description)
  }

// repeated uint32 links_add = 6;
  inline int ChannelState::links_add_size() const
  {
    return links_add_.size();
  }
  inline void ChannelState::clear_links_add()
  {
    links_add_.Clear();
  }
  inline ::google::protobuf::uint32 ChannelState::links_add(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links_add)
    return links_add_.Get(index);
  }
  inline void ChannelState::set_links_add(int index,
                                          ::google::protobuf::uint32 value)
  {
    links_add_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links_add)
  }
  inline void ChannelState::add_links_add(::google::protobuf::uint32 value)
  {
    links_add_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links_add)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  ChannelState::links_add() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links_add)
    return links_add_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  ChannelState::mutable_links_add()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links_add)
    return &links_add_;
  }

// repeated uint32 links_remove = 7;
  inline int ChannelState::links_remove_size() const
  {
    return links_remove_.size();
  }
  inline void ChannelState::clear_links_remove()
  {
    links_remove_.Clear();
  }
  inline ::google::protobuf::uint32 ChannelState::links_remove(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links_remove)
    return links_remove_.Get(index);
  }
  inline void ChannelState::set_links_remove(int index,
      ::google::protobuf::uint32 value)
  {
    links_remove_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links_remove)
  }
  inline void ChannelState::add_links_remove(::google::protobuf::uint32 value)
  {
    links_remove_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links_remove)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  ChannelState::links_remove() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links_remove)
    return links_remove_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  ChannelState::mutable_links_remove()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links_remove)
    return &links_remove_;
  }

// optional bool temporary = 8 [default = false];
  inline bool ChannelState::has_temporary() const
  {
    return (_has_bits_[0] & 0x00000080u) != 0;
  }
  inline void ChannelState::set_has_temporary()
  {
    _has_bits_[0] |= 0x00000080u;
  }
  inline void ChannelState::clear_has_temporary()
  {
    _has_bits_[0] &= ~0x00000080u;
  }
  inline void ChannelState::clear_temporary()
  {
    temporary_ = false;
    clear_has_temporary();
  }
  inline bool ChannelState::temporary() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.temporary)
    return temporary_;
  }
  inline void ChannelState::set_temporary(bool value)
  {
    set_has_temporary();
    temporary_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.temporary)
  }

// optional int32 position = 9 [default = 0];
  inline bool ChannelState::has_position() const
  {
    return (_has_bits_[0] & 0x00000100u) != 0;
  }
  inline void ChannelState::set_has_position()
  {
    _has_bits_[0] |= 0x00000100u;
  }
  inline void ChannelState::clear_has_position()
  {
    _has_bits_[0] &= ~0x00000100u;
  }
  inline void ChannelState::clear_position()
  {
    position_ = 0;
    clear_has_position();
  }
  inline ::google::protobuf::int32 ChannelState::position() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.position)
    return position_;
  }
  inline void ChannelState::set_position(::google::protobuf::int32 value)
  {
    set_has_position();
    position_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.position)
  }

// optional bytes description_hash = 10;
  inline bool ChannelState::has_description_hash() const
  {
    return (_has_bits_[0] & 0x00000200u) != 0;
  }
  inline void ChannelState::set_has_description_hash()
  {
    _has_bits_[0] |= 0x00000200u;
  }
  inline void ChannelState::clear_has_description_hash()
  {
    _has_bits_[0] &= ~0x00000200u;
  }
  inline void ChannelState::clear_description_hash()
  {
    if (description_hash_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_hash_->clear();
      }
    clear_has_description_hash();
  }
  inline const ::std::string& ChannelState::description_hash() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.description_hash)
    return *description_hash_;
  }
  inline void ChannelState::set_description_hash(const ::std::string& value)
  {
    set_has_description_hash();
    if (description_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_hash_ = new ::std::string;
      }
    description_hash_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.description_hash)
  }
  inline void ChannelState::set_description_hash(const char* value)
  {
    set_has_description_hash();
    if (description_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_hash_ = new ::std::string;
      }
    description_hash_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.description_hash)
  }
  inline void ChannelState::set_description_hash(const void* value, size_t size)
  {
    set_has_description_hash();
    if (description_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_hash_ = new ::std::string;
      }
    description_hash_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.description_hash)
  }
  inline ::std::string* ChannelState::mutable_description_hash()
  {
    set_has_description_hash();
    if (description_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        description_hash_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.description_hash)
    return description_hash_;
  }
  inline ::std::string* ChannelState::release_description_hash()
  {
    clear_has_description_hash();
    if (description_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = description_hash_;
        description_hash_ = const_cast< ::std::string*>
                            (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ChannelState::set_allocated_description_hash(
    ::std::string* description_hash)
  {
    if (description_hash_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete description_hash_;
      }
    if (description_hash)
      {
        set_has_description_hash();
        description_hash_ = description_hash;
      }
    else
      {
        clear_has_description_hash();
        description_hash_ = const_cast< ::std::string*>
                            (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.description_hash)
  }

// optional uint32 max_users = 11;
  inline bool ChannelState::has_max_users() const
  {
    return (_has_bits_[0] & 0x00000400u) != 0;
  }
  inline void ChannelState::set_has_max_users()
  {
    _has_bits_[0] |= 0x00000400u;
  }
  inline void ChannelState::clear_has_max_users()
  {
    _has_bits_[0] &= ~0x00000400u;
  }
  inline void ChannelState::clear_max_users()
  {
    max_users_ = 0u;
    clear_has_max_users();
  }
  inline ::google::protobuf::uint32 ChannelState::max_users() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.max_users)
    return max_users_;
  }
  inline void ChannelState::set_max_users(::google::protobuf::uint32 value)
  {
    set_has_max_users();
    max_users_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.max_users)
  }

// -------------------------------------------------------------------

// UserRemove

// required uint32 session = 1;
  inline bool UserRemove::has_session() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void UserRemove::set_has_session()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void UserRemove::clear_has_session()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void UserRemove::clear_session()
  {
    session_ = 0u;
    clear_has_session();
  }
  inline ::google::protobuf::uint32 UserRemove::session() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.session)
    return session_;
  }
  inline void UserRemove::set_session(::google::protobuf::uint32 value)
  {
    set_has_session();
    session_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.session)
  }

// optional uint32 actor = 2;
  inline bool UserRemove::has_actor() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void UserRemove::set_has_actor()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void UserRemove::clear_has_actor()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void UserRemove::clear_actor()
  {
    actor_ = 0u;
    clear_has_actor();
  }
  inline ::google::protobuf::uint32 UserRemove::actor() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.actor)
    return actor_;
  }
  inline void UserRemove::set_actor(::google::protobuf::uint32 value)
  {
    set_has_actor();
    actor_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.actor)
  }

// optional string reason = 3;
  inline bool UserRemove::has_reason() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void UserRemove::set_has_reason()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void UserRemove::clear_has_reason()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void UserRemove::clear_reason()
  {
    if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_->clear();
      }
    clear_has_reason();
  }
  inline const ::std::string& UserRemove::reason() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.reason)
    return *reason_;
  }
  inline void UserRemove::set_reason(const ::std::string& value)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.reason)
  }
  inline void UserRemove::set_reason(const char* value)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserRemove.reason)
  }
  inline void UserRemove::set_reason(const char* value, size_t size)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserRemove.reason)
  }
  inline ::std::string* UserRemove::mutable_reason()
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserRemove.reason)
    return reason_;
  }
  inline ::std::string* UserRemove::release_reason()
  {
    clear_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = reason_;
        reason_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserRemove::set_allocated_reason(::std::string* reason)
  {
    if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete reason_;
      }
    if (reason)
      {
        set_has_reason();
        reason_ = reason;
      }
    else
      {
        clear_has_reason();
        reason_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserRemove.reason)
  }

// optional bool ban = 4;
  inline bool UserRemove::has_ban() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void UserRemove::set_has_ban()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void UserRemove::clear_has_ban()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void UserRemove::clear_ban()
  {
    ban_ = false;
    clear_has_ban();
  }
  inline bool UserRemove::ban() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.ban)
    return ban_;
  }
  inline void UserRemove::set_ban(bool value)
  {
    set_has_ban();
    ban_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.ban)
  }

// -------------------------------------------------------------------

// UserState

// optional uint32 session = 1;
  inline bool UserState::has_session() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void UserState::set_has_session()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void UserState::clear_has_session()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void UserState::clear_session()
  {
    session_ = 0u;
    clear_has_session();
  }
  inline ::google::protobuf::uint32 UserState::session() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.session)
    return session_;
  }
  inline void UserState::set_session(::google::protobuf::uint32 value)
  {
    set_has_session();
    session_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.session)
  }

// optional uint32 actor = 2;
  inline bool UserState::has_actor() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void UserState::set_has_actor()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void UserState::clear_has_actor()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void UserState::clear_actor()
  {
    actor_ = 0u;
    clear_has_actor();
  }
  inline ::google::protobuf::uint32 UserState::actor() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.actor)
    return actor_;
  }
  inline void UserState::set_actor(::google::protobuf::uint32 value)
  {
    set_has_actor();
    actor_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.actor)
  }

// optional string name = 3;
  inline bool UserState::has_name() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void UserState::set_has_name()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void UserState::clear_has_name()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void UserState::clear_name()
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_->clear();
      }
    clear_has_name();
  }
  inline const ::std::string& UserState::name() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.name)
    return *name_;
  }
  inline void UserState::set_name(const ::std::string& value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.name)
  }
  inline void UserState::set_name(const char* value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.name)
  }
  inline void UserState::set_name(const char* value, size_t size)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.name)
  }
  inline ::std::string* UserState::mutable_name()
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.name)
    return name_;
  }
  inline ::std::string* UserState::release_name()
  {
    clear_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = name_;
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserState::set_allocated_name(::std::string* name)
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete name_;
      }
    if (name)
      {
        set_has_name();
        name_ = name;
      }
    else
      {
        clear_has_name();
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.name)
  }

// optional uint32 user_id = 4;
  inline bool UserState::has_user_id() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void UserState::set_has_user_id()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void UserState::clear_has_user_id()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void UserState::clear_user_id()
  {
    user_id_ = 0u;
    clear_has_user_id();
  }
  inline ::google::protobuf::uint32 UserState::user_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.user_id)
    return user_id_;
  }
  inline void UserState::set_user_id(::google::protobuf::uint32 value)
  {
    set_has_user_id();
    user_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.user_id)
  }

// optional uint32 channel_id = 5;
  inline bool UserState::has_channel_id() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void UserState::set_has_channel_id()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void UserState::clear_has_channel_id()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void UserState::clear_channel_id()
  {
    channel_id_ = 0u;
    clear_has_channel_id();
  }
  inline ::google::protobuf::uint32 UserState::channel_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.channel_id)
    return channel_id_;
  }
  inline void UserState::set_channel_id(::google::protobuf::uint32 value)
  {
    set_has_channel_id();
    channel_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.channel_id)
  }

// optional bool mute = 6;
  inline bool UserState::has_mute() const
  {
    return (_has_bits_[0] & 0x00000020u) != 0;
  }
  inline void UserState::set_has_mute()
  {
    _has_bits_[0] |= 0x00000020u;
  }
  inline void UserState::clear_has_mute()
  {
    _has_bits_[0] &= ~0x00000020u;
  }
  inline void UserState::clear_mute()
  {
    mute_ = false;
    clear_has_mute();
  }
  inline bool UserState::mute() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.mute)
    return mute_;
  }
  inline void UserState::set_mute(bool value)
  {
    set_has_mute();
    mute_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.mute)
  }

// optional bool deaf = 7;
  inline bool UserState::has_deaf() const
  {
    return (_has_bits_[0] & 0x00000040u) != 0;
  }
  inline void UserState::set_has_deaf()
  {
    _has_bits_[0] |= 0x00000040u;
  }
  inline void UserState::clear_has_deaf()
  {
    _has_bits_[0] &= ~0x00000040u;
  }
  inline void UserState::clear_deaf()
  {
    deaf_ = false;
    clear_has_deaf();
  }
  inline bool UserState::deaf() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.deaf)
    return deaf_;
  }
  inline void UserState::set_deaf(bool value)
  {
    set_has_deaf();
    deaf_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.deaf)
  }

// optional bool suppress = 8;
  inline bool UserState::has_suppress() const
  {
    return (_has_bits_[0] & 0x00000080u) != 0;
  }
  inline void UserState::set_has_suppress()
  {
    _has_bits_[0] |= 0x00000080u;
  }
  inline void UserState::clear_has_suppress()
  {
    _has_bits_[0] &= ~0x00000080u;
  }
  inline void UserState::clear_suppress()
  {
    suppress_ = false;
    clear_has_suppress();
  }
  inline bool UserState::suppress() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.suppress)
    return suppress_;
  }
  inline void UserState::set_suppress(bool value)
  {
    set_has_suppress();
    suppress_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.suppress)
  }

// optional bool self_mute = 9;
  inline bool UserState::has_self_mute() const
  {
    return (_has_bits_[0] & 0x00000100u) != 0;
  }
  inline void UserState::set_has_self_mute()
  {
    _has_bits_[0] |= 0x00000100u;
  }
  inline void UserState::clear_has_self_mute()
  {
    _has_bits_[0] &= ~0x00000100u;
  }
  inline void UserState::clear_self_mute()
  {
    self_mute_ = false;
    clear_has_self_mute();
  }
  inline bool UserState::self_mute() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.self_mute)
    return self_mute_;
  }
  inline void UserState::set_self_mute(bool value)
  {
    set_has_self_mute();
    self_mute_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.self_mute)
  }

// optional bool self_deaf = 10;
  inline bool UserState::has_self_deaf() const
  {
    return (_has_bits_[0] & 0x00000200u) != 0;
  }
  inline void UserState::set_has_self_deaf()
  {
    _has_bits_[0] |= 0x00000200u;
  }
  inline void UserState::clear_has_self_deaf()
  {
    _has_bits_[0] &= ~0x00000200u;
  }
  inline void UserState::clear_self_deaf()
  {
    self_deaf_ = false;
    clear_has_self_deaf();
  }
  inline bool UserState::self_deaf() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.self_deaf)
    return self_deaf_;
  }
  inline void UserState::set_self_deaf(bool value)
  {
    set_has_self_deaf();
    self_deaf_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.self_deaf)
  }

// optional bytes texture = 11;
  inline bool UserState::has_texture() const
  {
    return (_has_bits_[0] & 0x00000400u) != 0;
  }
  inline void UserState::set_has_texture()
  {
    _has_bits_[0] |= 0x00000400u;
  }
  inline void UserState::clear_has_texture()
  {
    _has_bits_[0] &= ~0x00000400u;
  }
  inline void UserState::clear_texture()
  {
    if (texture_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_->clear();
      }
    clear_has_texture();
  }
  inline const ::std::string& UserState::texture() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.texture)
    return *texture_;
  }
  inline void UserState::set_texture(const ::std::string& value)
  {
    set_has_texture();
    if (texture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_ = new ::std::string;
      }
    texture_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.texture)
  }
  inline void UserState::set_texture(const char* value)
  {
    set_has_texture();
    if (texture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_ = new ::std::string;
      }
    texture_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.texture)
  }
  inline void UserState::set_texture(const void* value, size_t size)
  {
    set_has_texture();
    if (texture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_ = new ::std::string;
      }
    texture_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.texture)
  }
  inline ::std::string* UserState::mutable_texture()
  {
    set_has_texture();
    if (texture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.texture)
    return texture_;
  }
  inline ::std::string* UserState::release_texture()
  {
    clear_has_texture();
    if (texture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = texture_;
        texture_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserState::set_allocated_texture(::std::string* texture)
  {
    if (texture_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete texture_;
      }
    if (texture)
      {
        set_has_texture();
        texture_ = texture;
      }
    else
      {
        clear_has_texture();
        texture_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.texture)
  }

// optional bytes plugin_context = 12;
  inline bool UserState::has_plugin_context() const
  {
    return (_has_bits_[0] & 0x00000800u) != 0;
  }
  inline void UserState::set_has_plugin_context()
  {
    _has_bits_[0] |= 0x00000800u;
  }
  inline void UserState::clear_has_plugin_context()
  {
    _has_bits_[0] &= ~0x00000800u;
  }
  inline void UserState::clear_plugin_context()
  {
    if (plugin_context_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_context_->clear();
      }
    clear_has_plugin_context();
  }
  inline const ::std::string& UserState::plugin_context() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.plugin_context)
    return *plugin_context_;
  }
  inline void UserState::set_plugin_context(const ::std::string& value)
  {
    set_has_plugin_context();
    if (plugin_context_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_context_ = new ::std::string;
      }
    plugin_context_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.plugin_context)
  }
  inline void UserState::set_plugin_context(const char* value)
  {
    set_has_plugin_context();
    if (plugin_context_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_context_ = new ::std::string;
      }
    plugin_context_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.plugin_context)
  }
  inline void UserState::set_plugin_context(const void* value, size_t size)
  {
    set_has_plugin_context();
    if (plugin_context_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_context_ = new ::std::string;
      }
    plugin_context_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.plugin_context)
  }
  inline ::std::string* UserState::mutable_plugin_context()
  {
    set_has_plugin_context();
    if (plugin_context_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_context_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.plugin_context)
    return plugin_context_;
  }
  inline ::std::string* UserState::release_plugin_context()
  {
    clear_has_plugin_context();
    if (plugin_context_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = plugin_context_;
        plugin_context_ = const_cast< ::std::string*>
                          (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserState::set_allocated_plugin_context(::std::string*
      plugin_context)
  {
    if (plugin_context_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete plugin_context_;
      }
    if (plugin_context)
      {
        set_has_plugin_context();
        plugin_context_ = plugin_context;
      }
    else
      {
        clear_has_plugin_context();
        plugin_context_ = const_cast< ::std::string*>
                          (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.plugin_context)
  }

// optional string plugin_identity = 13;
  inline bool UserState::has_plugin_identity() const
  {
    return (_has_bits_[0] & 0x00001000u) != 0;
  }
  inline void UserState::set_has_plugin_identity()
  {
    _has_bits_[0] |= 0x00001000u;
  }
  inline void UserState::clear_has_plugin_identity()
  {
    _has_bits_[0] &= ~0x00001000u;
  }
  inline void UserState::clear_plugin_identity()
  {
    if (plugin_identity_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_identity_->clear();
      }
    clear_has_plugin_identity();
  }
  inline const ::std::string& UserState::plugin_identity() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.plugin_identity)
    return *plugin_identity_;
  }
  inline void UserState::set_plugin_identity(const ::std::string& value)
  {
    set_has_plugin_identity();
    if (plugin_identity_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_identity_ = new ::std::string;
      }
    plugin_identity_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.plugin_identity)
  }
  inline void UserState::set_plugin_identity(const char* value)
  {
    set_has_plugin_identity();
    if (plugin_identity_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_identity_ = new ::std::string;
      }
    plugin_identity_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.plugin_identity)
  }
  inline void UserState::set_plugin_identity(const char* value, size_t size)
  {
    set_has_plugin_identity();
    if (plugin_identity_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_identity_ = new ::std::string;
      }
    plugin_identity_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.plugin_identity)
  }
  inline ::std::string* UserState::mutable_plugin_identity()
  {
    set_has_plugin_identity();
    if (plugin_identity_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        plugin_identity_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.plugin_identity)
    return plugin_identity_;
  }
  inline ::std::string* UserState::release_plugin_identity()
  {
    clear_has_plugin_identity();
    if (plugin_identity_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = plugin_identity_;
        plugin_identity_ = const_cast< ::std::string*>
                           (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserState::set_allocated_plugin_identity(::std::string*
      plugin_identity)
  {
    if (plugin_identity_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete plugin_identity_;
      }
    if (plugin_identity)
      {
        set_has_plugin_identity();
        plugin_identity_ = plugin_identity;
      }
    else
      {
        clear_has_plugin_identity();
        plugin_identity_ = const_cast< ::std::string*>
                           (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.plugin_identity)
  }

// optional string comment = 14;
  inline bool UserState::has_comment() const
  {
    return (_has_bits_[0] & 0x00002000u) != 0;
  }
  inline void UserState::set_has_comment()
  {
    _has_bits_[0] |= 0x00002000u;
  }
  inline void UserState::clear_has_comment()
  {
    _has_bits_[0] &= ~0x00002000u;
  }
  inline void UserState::clear_comment()
  {
    if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_->clear();
      }
    clear_has_comment();
  }
  inline const ::std::string& UserState::comment() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.comment)
    return *comment_;
  }
  inline void UserState::set_comment(const ::std::string& value)
  {
    set_has_comment();
    if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_ = new ::std::string;
      }
    comment_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.comment)
  }
  inline void UserState::set_comment(const char* value)
  {
    set_has_comment();
    if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_ = new ::std::string;
      }
    comment_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.comment)
  }
  inline void UserState::set_comment(const char* value, size_t size)
  {
    set_has_comment();
    if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_ = new ::std::string;
      }
    comment_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.comment)
  }
  inline ::std::string* UserState::mutable_comment()
  {
    set_has_comment();
    if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.comment)
    return comment_;
  }
  inline ::std::string* UserState::release_comment()
  {
    clear_has_comment();
    if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = comment_;
        comment_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserState::set_allocated_comment(::std::string* comment)
  {
    if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete comment_;
      }
    if (comment)
      {
        set_has_comment();
        comment_ = comment;
      }
    else
      {
        clear_has_comment();
        comment_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.comment)
  }

// optional string hash = 15;
  inline bool UserState::has_hash() const
  {
    return (_has_bits_[0] & 0x00004000u) != 0;
  }
  inline void UserState::set_has_hash()
  {
    _has_bits_[0] |= 0x00004000u;
  }
  inline void UserState::clear_has_hash()
  {
    _has_bits_[0] &= ~0x00004000u;
  }
  inline void UserState::clear_hash()
  {
    if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_->clear();
      }
    clear_has_hash();
  }
  inline const ::std::string& UserState::hash() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.hash)
    return *hash_;
  }
  inline void UserState::set_hash(const ::std::string& value)
  {
    set_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_ = new ::std::string;
      }
    hash_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.hash)
  }
  inline void UserState::set_hash(const char* value)
  {
    set_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_ = new ::std::string;
      }
    hash_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.hash)
  }
  inline void UserState::set_hash(const char* value, size_t size)
  {
    set_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_ = new ::std::string;
      }
    hash_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.hash)
  }
  inline ::std::string* UserState::mutable_hash()
  {
    set_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.hash)
    return hash_;
  }
  inline ::std::string* UserState::release_hash()
  {
    clear_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = hash_;
        hash_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserState::set_allocated_hash(::std::string* hash)
  {
    if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete hash_;
      }
    if (hash)
      {
        set_has_hash();
        hash_ = hash;
      }
    else
      {
        clear_has_hash();
        hash_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.hash)
  }

// optional bytes comment_hash = 16;
  inline bool UserState::has_comment_hash() const
  {
    return (_has_bits_[0] & 0x00008000u) != 0;
  }
  inline void UserState::set_has_comment_hash()
  {
    _has_bits_[0] |= 0x00008000u;
  }
  inline void UserState::clear_has_comment_hash()
  {
    _has_bits_[0] &= ~0x00008000u;
  }
  inline void UserState::clear_comment_hash()
  {
    if (comment_hash_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_hash_->clear();
      }
    clear_has_comment_hash();
  }
  inline const ::std::string& UserState::comment_hash() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.comment_hash)
    return *comment_hash_;
  }
  inline void UserState::set_comment_hash(const ::std::string& value)
  {
    set_has_comment_hash();
    if (comment_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_hash_ = new ::std::string;
      }
    comment_hash_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.comment_hash)
  }
  inline void UserState::set_comment_hash(const char* value)
  {
    set_has_comment_hash();
    if (comment_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_hash_ = new ::std::string;
      }
    comment_hash_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.comment_hash)
  }
  inline void UserState::set_comment_hash(const void* value, size_t size)
  {
    set_has_comment_hash();
    if (comment_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_hash_ = new ::std::string;
      }
    comment_hash_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.comment_hash)
  }
  inline ::std::string* UserState::mutable_comment_hash()
  {
    set_has_comment_hash();
    if (comment_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        comment_hash_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.comment_hash)
    return comment_hash_;
  }
  inline ::std::string* UserState::release_comment_hash()
  {
    clear_has_comment_hash();
    if (comment_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = comment_hash_;
        comment_hash_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserState::set_allocated_comment_hash(::std::string* comment_hash)
  {
    if (comment_hash_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete comment_hash_;
      }
    if (comment_hash)
      {
        set_has_comment_hash();
        comment_hash_ = comment_hash;
      }
    else
      {
        clear_has_comment_hash();
        comment_hash_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.comment_hash)
  }

// optional bytes texture_hash = 17;
  inline bool UserState::has_texture_hash() const
  {
    return (_has_bits_[0] & 0x00010000u) != 0;
  }
  inline void UserState::set_has_texture_hash()
  {
    _has_bits_[0] |= 0x00010000u;
  }
  inline void UserState::clear_has_texture_hash()
  {
    _has_bits_[0] &= ~0x00010000u;
  }
  inline void UserState::clear_texture_hash()
  {
    if (texture_hash_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_hash_->clear();
      }
    clear_has_texture_hash();
  }
  inline const ::std::string& UserState::texture_hash() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.texture_hash)
    return *texture_hash_;
  }
  inline void UserState::set_texture_hash(const ::std::string& value)
  {
    set_has_texture_hash();
    if (texture_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_hash_ = new ::std::string;
      }
    texture_hash_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.texture_hash)
  }
  inline void UserState::set_texture_hash(const char* value)
  {
    set_has_texture_hash();
    if (texture_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_hash_ = new ::std::string;
      }
    texture_hash_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.texture_hash)
  }
  inline void UserState::set_texture_hash(const void* value, size_t size)
  {
    set_has_texture_hash();
    if (texture_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_hash_ = new ::std::string;
      }
    texture_hash_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.texture_hash)
  }
  inline ::std::string* UserState::mutable_texture_hash()
  {
    set_has_texture_hash();
    if (texture_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        texture_hash_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.texture_hash)
    return texture_hash_;
  }
  inline ::std::string* UserState::release_texture_hash()
  {
    clear_has_texture_hash();
    if (texture_hash_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = texture_hash_;
        texture_hash_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserState::set_allocated_texture_hash(::std::string* texture_hash)
  {
    if (texture_hash_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete texture_hash_;
      }
    if (texture_hash)
      {
        set_has_texture_hash();
        texture_hash_ = texture_hash;
      }
    else
      {
        clear_has_texture_hash();
        texture_hash_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.texture_hash)
  }

// optional bool priority_speaker = 18;
  inline bool UserState::has_priority_speaker() const
  {
    return (_has_bits_[0] & 0x00020000u) != 0;
  }
  inline void UserState::set_has_priority_speaker()
  {
    _has_bits_[0] |= 0x00020000u;
  }
  inline void UserState::clear_has_priority_speaker()
  {
    _has_bits_[0] &= ~0x00020000u;
  }
  inline void UserState::clear_priority_speaker()
  {
    priority_speaker_ = false;
    clear_has_priority_speaker();
  }
  inline bool UserState::priority_speaker() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.priority_speaker)
    return priority_speaker_;
  }
  inline void UserState::set_priority_speaker(bool value)
  {
    set_has_priority_speaker();
    priority_speaker_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.priority_speaker)
  }

// optional bool recording = 19;
  inline bool UserState::has_recording() const
  {
    return (_has_bits_[0] & 0x00040000u) != 0;
  }
  inline void UserState::set_has_recording()
  {
    _has_bits_[0] |= 0x00040000u;
  }
  inline void UserState::clear_has_recording()
  {
    _has_bits_[0] &= ~0x00040000u;
  }
  inline void UserState::clear_recording()
  {
    recording_ = false;
    clear_has_recording();
  }
  inline bool UserState::recording() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserState.recording)
    return recording_;
  }
  inline void UserState::set_recording(bool value)
  {
    set_has_recording();
    recording_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserState.recording)
  }

// -------------------------------------------------------------------

// BanList_BanEntry

// required bytes address = 1;
  inline bool BanList_BanEntry::has_address() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void BanList_BanEntry::set_has_address()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void BanList_BanEntry::clear_has_address()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void BanList_BanEntry::clear_address()
  {
    if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_->clear();
      }
    clear_has_address();
  }
  inline const ::std::string& BanList_BanEntry::address() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.address)
    return *address_;
  }
  inline void BanList_BanEntry::set_address(const ::std::string& value)
  {
    set_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_ = new ::std::string;
      }
    address_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.address)
  }
  inline void BanList_BanEntry::set_address(const char* value)
  {
    set_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_ = new ::std::string;
      }
    address_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.address)
  }
  inline void BanList_BanEntry::set_address(const void* value, size_t size)
  {
    set_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_ = new ::std::string;
      }
    address_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.address)
  }
  inline ::std::string* BanList_BanEntry::mutable_address()
  {
    set_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.address)
    return address_;
  }
  inline ::std::string* BanList_BanEntry::release_address()
  {
    clear_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = address_;
        address_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void BanList_BanEntry::set_allocated_address(::std::string* address)
  {
    if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete address_;
      }
    if (address)
      {
        set_has_address();
        address_ = address;
      }
    else
      {
        clear_has_address();
        address_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.address)
  }

// required uint32 mask = 2;
  inline bool BanList_BanEntry::has_mask() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void BanList_BanEntry::set_has_mask()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void BanList_BanEntry::clear_has_mask()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void BanList_BanEntry::clear_mask()
  {
    mask_ = 0u;
    clear_has_mask();
  }
  inline ::google::protobuf::uint32 BanList_BanEntry::mask() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.mask)
    return mask_;
  }
  inline void BanList_BanEntry::set_mask(::google::protobuf::uint32 value)
  {
    set_has_mask();
    mask_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.mask)
  }

// optional string name = 3;
  inline bool BanList_BanEntry::has_name() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void BanList_BanEntry::set_has_name()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void BanList_BanEntry::clear_has_name()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void BanList_BanEntry::clear_name()
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_->clear();
      }
    clear_has_name();
  }
  inline const ::std::string& BanList_BanEntry::name() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.name)
    return *name_;
  }
  inline void BanList_BanEntry::set_name(const ::std::string& value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.name)
  }
  inline void BanList_BanEntry::set_name(const char* value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.name)
  }
  inline void BanList_BanEntry::set_name(const char* value, size_t size)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.name)
  }
  inline ::std::string* BanList_BanEntry::mutable_name()
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.name)
    return name_;
  }
  inline ::std::string* BanList_BanEntry::release_name()
  {
    clear_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = name_;
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void BanList_BanEntry::set_allocated_name(::std::string* name)
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete name_;
      }
    if (name)
      {
        set_has_name();
        name_ = name;
      }
    else
      {
        clear_has_name();
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.name)
  }

// optional string hash = 4;
  inline bool BanList_BanEntry::has_hash() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void BanList_BanEntry::set_has_hash()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void BanList_BanEntry::clear_has_hash()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void BanList_BanEntry::clear_hash()
  {
    if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_->clear();
      }
    clear_has_hash();
  }
  inline const ::std::string& BanList_BanEntry::hash() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.hash)
    return *hash_;
  }
  inline void BanList_BanEntry::set_hash(const ::std::string& value)
  {
    set_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_ = new ::std::string;
      }
    hash_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.hash)
  }
  inline void BanList_BanEntry::set_hash(const char* value)
  {
    set_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_ = new ::std::string;
      }
    hash_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.hash)
  }
  inline void BanList_BanEntry::set_hash(const char* value, size_t size)
  {
    set_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_ = new ::std::string;
      }
    hash_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.hash)
  }
  inline ::std::string* BanList_BanEntry::mutable_hash()
  {
    set_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        hash_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.hash)
    return hash_;
  }
  inline ::std::string* BanList_BanEntry::release_hash()
  {
    clear_has_hash();
    if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = hash_;
        hash_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void BanList_BanEntry::set_allocated_hash(::std::string* hash)
  {
    if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete hash_;
      }
    if (hash)
      {
        set_has_hash();
        hash_ = hash;
      }
    else
      {
        clear_has_hash();
        hash_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.hash)
  }

// optional string reason = 5;
  inline bool BanList_BanEntry::has_reason() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void BanList_BanEntry::set_has_reason()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void BanList_BanEntry::clear_has_reason()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void BanList_BanEntry::clear_reason()
  {
    if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_->clear();
      }
    clear_has_reason();
  }
  inline const ::std::string& BanList_BanEntry::reason() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.reason)
    return *reason_;
  }
  inline void BanList_BanEntry::set_reason(const ::std::string& value)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.reason)
  }
  inline void BanList_BanEntry::set_reason(const char* value)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.reason)
  }
  inline void BanList_BanEntry::set_reason(const char* value, size_t size)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.reason)
  }
  inline ::std::string* BanList_BanEntry::mutable_reason()
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.reason)
    return reason_;
  }
  inline ::std::string* BanList_BanEntry::release_reason()
  {
    clear_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = reason_;
        reason_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void BanList_BanEntry::set_allocated_reason(::std::string* reason)
  {
    if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete reason_;
      }
    if (reason)
      {
        set_has_reason();
        reason_ = reason;
      }
    else
      {
        clear_has_reason();
        reason_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.reason)
  }

// optional string start = 6;
  inline bool BanList_BanEntry::has_start() const
  {
    return (_has_bits_[0] & 0x00000020u) != 0;
  }
  inline void BanList_BanEntry::set_has_start()
  {
    _has_bits_[0] |= 0x00000020u;
  }
  inline void BanList_BanEntry::clear_has_start()
  {
    _has_bits_[0] &= ~0x00000020u;
  }
  inline void BanList_BanEntry::clear_start()
  {
    if (start_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        start_->clear();
      }
    clear_has_start();
  }
  inline const ::std::string& BanList_BanEntry::start() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.start)
    return *start_;
  }
  inline void BanList_BanEntry::set_start(const ::std::string& value)
  {
    set_has_start();
    if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        start_ = new ::std::string;
      }
    start_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.start)
  }
  inline void BanList_BanEntry::set_start(const char* value)
  {
    set_has_start();
    if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        start_ = new ::std::string;
      }
    start_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.start)
  }
  inline void BanList_BanEntry::set_start(const char* value, size_t size)
  {
    set_has_start();
    if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        start_ = new ::std::string;
      }
    start_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.start)
  }
  inline ::std::string* BanList_BanEntry::mutable_start()
  {
    set_has_start();
    if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        start_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.start)
    return start_;
  }
  inline ::std::string* BanList_BanEntry::release_start()
  {
    clear_has_start();
    if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = start_;
        start_ = const_cast< ::std::string*>
                 (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void BanList_BanEntry::set_allocated_start(::std::string* start)
  {
    if (start_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete start_;
      }
    if (start)
      {
        set_has_start();
        start_ = start;
      }
    else
      {
        clear_has_start();
        start_ = const_cast< ::std::string*>
                 (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.start)
  }

// optional uint32 duration = 7;
  inline bool BanList_BanEntry::has_duration() const
  {
    return (_has_bits_[0] & 0x00000040u) != 0;
  }
  inline void BanList_BanEntry::set_has_duration()
  {
    _has_bits_[0] |= 0x00000040u;
  }
  inline void BanList_BanEntry::clear_has_duration()
  {
    _has_bits_[0] &= ~0x00000040u;
  }
  inline void BanList_BanEntry::clear_duration()
  {
    duration_ = 0u;
    clear_has_duration();
  }
  inline ::google::protobuf::uint32 BanList_BanEntry::duration() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.duration)
    return duration_;
  }
  inline void BanList_BanEntry::set_duration(::google::protobuf::uint32 value)
  {
    set_has_duration();
    duration_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.duration)
  }

// -------------------------------------------------------------------

// BanList

// repeated .MumbleProto.BanList.BanEntry bans = 1;
  inline int BanList::bans_size() const
  {
    return bans_.size();
  }
  inline void BanList::clear_bans()
  {
    bans_.Clear();
  }
  inline const ::MumbleProto::BanList_BanEntry& BanList::bans(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.BanList.bans)
    return bans_.Get(index);
  }
  inline ::MumbleProto::BanList_BanEntry* BanList::mutable_bans(int index)
  {
    // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.bans)
    return bans_.Mutable(index);
  }
  inline ::MumbleProto::BanList_BanEntry* BanList::add_bans()
  {
    // @@protoc_insertion_point(field_add:MumbleProto.BanList.bans)
    return bans_.Add();
  }
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
  BanList::bans() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.BanList.bans)
    return bans_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
  BanList::mutable_bans()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.BanList.bans)
    return &bans_;
  }

// optional bool query = 2 [default = false];
  inline bool BanList::has_query() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void BanList::set_has_query()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void BanList::clear_has_query()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void BanList::clear_query()
  {
    query_ = false;
    clear_has_query();
  }
  inline bool BanList::query() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.BanList.query)
    return query_;
  }
  inline void BanList::set_query(bool value)
  {
    set_has_query();
    query_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.BanList.query)
  }

// -------------------------------------------------------------------

// TextMessage

// optional uint32 actor = 1;
  inline bool TextMessage::has_actor() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void TextMessage::set_has_actor()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void TextMessage::clear_has_actor()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void TextMessage::clear_actor()
  {
    actor_ = 0u;
    clear_has_actor();
  }
  inline ::google::protobuf::uint32 TextMessage::actor() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.actor)
    return actor_;
  }
  inline void TextMessage::set_actor(::google::protobuf::uint32 value)
  {
    set_has_actor();
    actor_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.actor)
  }

// repeated uint32 session = 2;
  inline int TextMessage::session_size() const
  {
    return session_.size();
  }
  inline void TextMessage::clear_session()
  {
    session_.Clear();
  }
  inline ::google::protobuf::uint32 TextMessage::session(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.session)
    return session_.Get(index);
  }
  inline void TextMessage::set_session(int index,
                                       ::google::protobuf::uint32 value)
  {
    session_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.session)
  }
  inline void TextMessage::add_session(::google::protobuf::uint32 value)
  {
    session_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.session)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  TextMessage::session() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.session)
    return session_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  TextMessage::mutable_session()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.session)
    return &session_;
  }

// repeated uint32 channel_id = 3;
  inline int TextMessage::channel_id_size() const
  {
    return channel_id_.size();
  }
  inline void TextMessage::clear_channel_id()
  {
    channel_id_.Clear();
  }
  inline ::google::protobuf::uint32 TextMessage::channel_id(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.channel_id)
    return channel_id_.Get(index);
  }
  inline void TextMessage::set_channel_id(int index,
                                          ::google::protobuf::uint32 value)
  {
    channel_id_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.channel_id)
  }
  inline void TextMessage::add_channel_id(::google::protobuf::uint32 value)
  {
    channel_id_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.channel_id)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  TextMessage::channel_id() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.channel_id)
    return channel_id_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  TextMessage::mutable_channel_id()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.channel_id)
    return &channel_id_;
  }

// repeated uint32 tree_id = 4;
  inline int TextMessage::tree_id_size() const
  {
    return tree_id_.size();
  }
  inline void TextMessage::clear_tree_id()
  {
    tree_id_.Clear();
  }
  inline ::google::protobuf::uint32 TextMessage::tree_id(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.tree_id)
    return tree_id_.Get(index);
  }
  inline void TextMessage::set_tree_id(int index,
                                       ::google::protobuf::uint32 value)
  {
    tree_id_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.tree_id)
  }
  inline void TextMessage::add_tree_id(::google::protobuf::uint32 value)
  {
    tree_id_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.tree_id)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  TextMessage::tree_id() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.tree_id)
    return tree_id_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  TextMessage::mutable_tree_id()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.tree_id)
    return &tree_id_;
  }

// required string message = 5;
  inline bool TextMessage::has_message() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void TextMessage::set_has_message()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void TextMessage::clear_has_message()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void TextMessage::clear_message()
  {
    if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        message_->clear();
      }
    clear_has_message();
  }
  inline const ::std::string& TextMessage::message() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.message)
    return *message_;
  }
  inline void TextMessage::set_message(const ::std::string& value)
  {
    set_has_message();
    if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        message_ = new ::std::string;
      }
    message_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.message)
  }
  inline void TextMessage::set_message(const char* value)
  {
    set_has_message();
    if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        message_ = new ::std::string;
      }
    message_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.TextMessage.message)
  }
  inline void TextMessage::set_message(const char* value, size_t size)
  {
    set_has_message();
    if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        message_ = new ::std::string;
      }
    message_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.TextMessage.message)
  }
  inline ::std::string* TextMessage::mutable_message()
  {
    set_has_message();
    if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        message_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.TextMessage.message)
    return message_;
  }
  inline ::std::string* TextMessage::release_message()
  {
    clear_has_message();
    if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = message_;
        message_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void TextMessage::set_allocated_message(::std::string* message)
  {
    if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete message_;
      }
    if (message)
      {
        set_has_message();
        message_ = message;
      }
    else
      {
        clear_has_message();
        message_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.TextMessage.message)
  }

// -------------------------------------------------------------------

// PermissionDenied

// optional uint32 permission = 1;
  inline bool PermissionDenied::has_permission() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void PermissionDenied::set_has_permission()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void PermissionDenied::clear_has_permission()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void PermissionDenied::clear_permission()
  {
    permission_ = 0u;
    clear_has_permission();
  }
  inline ::google::protobuf::uint32 PermissionDenied::permission() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.permission)
    return permission_;
  }
  inline void PermissionDenied::set_permission(::google::protobuf::uint32 value)
  {
    set_has_permission();
    permission_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.permission)
  }

// optional uint32 channel_id = 2;
  inline bool PermissionDenied::has_channel_id() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void PermissionDenied::set_has_channel_id()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void PermissionDenied::clear_has_channel_id()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void PermissionDenied::clear_channel_id()
  {
    channel_id_ = 0u;
    clear_has_channel_id();
  }
  inline ::google::protobuf::uint32 PermissionDenied::channel_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.channel_id)
    return channel_id_;
  }
  inline void PermissionDenied::set_channel_id(::google::protobuf::uint32 value)
  {
    set_has_channel_id();
    channel_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.channel_id)
  }

// optional uint32 session = 3;
  inline bool PermissionDenied::has_session() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void PermissionDenied::set_has_session()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void PermissionDenied::clear_has_session()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void PermissionDenied::clear_session()
  {
    session_ = 0u;
    clear_has_session();
  }
  inline ::google::protobuf::uint32 PermissionDenied::session() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.session)
    return session_;
  }
  inline void PermissionDenied::set_session(::google::protobuf::uint32 value)
  {
    set_has_session();
    session_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.session)
  }

// optional string reason = 4;
  inline bool PermissionDenied::has_reason() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void PermissionDenied::set_has_reason()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void PermissionDenied::clear_has_reason()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void PermissionDenied::clear_reason()
  {
    if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_->clear();
      }
    clear_has_reason();
  }
  inline const ::std::string& PermissionDenied::reason() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.reason)
    return *reason_;
  }
  inline void PermissionDenied::set_reason(const ::std::string& value)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.reason)
  }
  inline void PermissionDenied::set_reason(const char* value)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.PermissionDenied.reason)
  }
  inline void PermissionDenied::set_reason(const char* value, size_t size)
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    reason_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.PermissionDenied.reason)
  }
  inline ::std::string* PermissionDenied::mutable_reason()
  {
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        reason_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.PermissionDenied.reason)
    return reason_;
  }
  inline ::std::string* PermissionDenied::release_reason()
  {
    clear_has_reason();
    if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = reason_;
        reason_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void PermissionDenied::set_allocated_reason(::std::string* reason)
  {
    if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete reason_;
      }
    if (reason)
      {
        set_has_reason();
        reason_ = reason;
      }
    else
      {
        clear_has_reason();
        reason_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.PermissionDenied.reason)
  }

// optional .MumbleProto.PermissionDenied.DenyType type = 5;
  inline bool PermissionDenied::has_type() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void PermissionDenied::set_has_type()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void PermissionDenied::clear_has_type()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void PermissionDenied::clear_type()
  {
    type_ = 0;
    clear_has_type();
  }
  inline ::MumbleProto::PermissionDenied_DenyType PermissionDenied::type() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.type)
    return static_cast< ::MumbleProto::PermissionDenied_DenyType >(type_);
  }
  inline void PermissionDenied::set_type(::MumbleProto::PermissionDenied_DenyType
                                         value)
  {
    assert(::MumbleProto::PermissionDenied_DenyType_IsValid(value));
    set_has_type();
    type_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.type)
  }

// optional string name = 6;
  inline bool PermissionDenied::has_name() const
  {
    return (_has_bits_[0] & 0x00000020u) != 0;
  }
  inline void PermissionDenied::set_has_name()
  {
    _has_bits_[0] |= 0x00000020u;
  }
  inline void PermissionDenied::clear_has_name()
  {
    _has_bits_[0] &= ~0x00000020u;
  }
  inline void PermissionDenied::clear_name()
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_->clear();
      }
    clear_has_name();
  }
  inline const ::std::string& PermissionDenied::name() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.name)
    return *name_;
  }
  inline void PermissionDenied::set_name(const ::std::string& value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.name)
  }
  inline void PermissionDenied::set_name(const char* value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.PermissionDenied.name)
  }
  inline void PermissionDenied::set_name(const char* value, size_t size)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.PermissionDenied.name)
  }
  inline ::std::string* PermissionDenied::mutable_name()
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.PermissionDenied.name)
    return name_;
  }
  inline ::std::string* PermissionDenied::release_name()
  {
    clear_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = name_;
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void PermissionDenied::set_allocated_name(::std::string* name)
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete name_;
      }
    if (name)
      {
        set_has_name();
        name_ = name;
      }
    else
      {
        clear_has_name();
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.PermissionDenied.name)
  }

// -------------------------------------------------------------------

// ACL_ChanGroup

// required string name = 1;
  inline bool ACL_ChanGroup::has_name() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void ACL_ChanGroup::set_has_name()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void ACL_ChanGroup::clear_has_name()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void ACL_ChanGroup::clear_name()
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_->clear();
      }
    clear_has_name();
  }
  inline const ::std::string& ACL_ChanGroup::name() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.name)
    return *name_;
  }
  inline void ACL_ChanGroup::set_name(const ::std::string& value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.name)
  }
  inline void ACL_ChanGroup::set_name(const char* value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ACL.ChanGroup.name)
  }
  inline void ACL_ChanGroup::set_name(const char* value, size_t size)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ACL.ChanGroup.name)
  }
  inline ::std::string* ACL_ChanGroup::mutable_name()
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.ChanGroup.name)
    return name_;
  }
  inline ::std::string* ACL_ChanGroup::release_name()
  {
    clear_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = name_;
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ACL_ChanGroup::set_allocated_name(::std::string* name)
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete name_;
      }
    if (name)
      {
        set_has_name();
        name_ = name;
      }
    else
      {
        clear_has_name();
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ACL.ChanGroup.name)
  }

// optional bool inherited = 2 [default = true];
  inline bool ACL_ChanGroup::has_inherited() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void ACL_ChanGroup::set_has_inherited()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void ACL_ChanGroup::clear_has_inherited()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void ACL_ChanGroup::clear_inherited()
  {
    inherited_ = true;
    clear_has_inherited();
  }
  inline bool ACL_ChanGroup::inherited() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherited)
    return inherited_;
  }
  inline void ACL_ChanGroup::set_inherited(bool value)
  {
    set_has_inherited();
    inherited_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherited)
  }

// optional bool inherit = 3 [default = true];
  inline bool ACL_ChanGroup::has_inherit() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void ACL_ChanGroup::set_has_inherit()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void ACL_ChanGroup::clear_has_inherit()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void ACL_ChanGroup::clear_inherit()
  {
    inherit_ = true;
    clear_has_inherit();
  }
  inline bool ACL_ChanGroup::inherit() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherit)
    return inherit_;
  }
  inline void ACL_ChanGroup::set_inherit(bool value)
  {
    set_has_inherit();
    inherit_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherit)
  }

// optional bool inheritable = 4 [default = true];
  inline bool ACL_ChanGroup::has_inheritable() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void ACL_ChanGroup::set_has_inheritable()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void ACL_ChanGroup::clear_has_inheritable()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void ACL_ChanGroup::clear_inheritable()
  {
    inheritable_ = true;
    clear_has_inheritable();
  }
  inline bool ACL_ChanGroup::inheritable() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inheritable)
    return inheritable_;
  }
  inline void ACL_ChanGroup::set_inheritable(bool value)
  {
    set_has_inheritable();
    inheritable_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inheritable)
  }

// repeated uint32 add = 5;
  inline int ACL_ChanGroup::add_size() const
  {
    return add_.size();
  }
  inline void ACL_ChanGroup::clear_add()
  {
    add_.Clear();
  }
  inline ::google::protobuf::uint32 ACL_ChanGroup::add(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.add)
    return add_.Get(index);
  }
  inline void ACL_ChanGroup::set_add(int index, ::google::protobuf::uint32 value)
  {
    add_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.add)
  }
  inline void ACL_ChanGroup::add_add(::google::protobuf::uint32 value)
  {
    add_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.add)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  ACL_ChanGroup::add() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.add)
    return add_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  ACL_ChanGroup::mutable_add()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.add)
    return &add_;
  }

// repeated uint32 remove = 6;
  inline int ACL_ChanGroup::remove_size() const
  {
    return remove_.size();
  }
  inline void ACL_ChanGroup::clear_remove()
  {
    remove_.Clear();
  }
  inline ::google::protobuf::uint32 ACL_ChanGroup::remove(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.remove)
    return remove_.Get(index);
  }
  inline void ACL_ChanGroup::set_remove(int index,
                                        ::google::protobuf::uint32 value)
  {
    remove_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.remove)
  }
  inline void ACL_ChanGroup::add_remove(::google::protobuf::uint32 value)
  {
    remove_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.remove)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  ACL_ChanGroup::remove() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.remove)
    return remove_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  ACL_ChanGroup::mutable_remove()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.remove)
    return &remove_;
  }

// repeated uint32 inherited_members = 7;
  inline int ACL_ChanGroup::inherited_members_size() const
  {
    return inherited_members_.size();
  }
  inline void ACL_ChanGroup::clear_inherited_members()
  {
    inherited_members_.Clear();
  }
  inline ::google::protobuf::uint32 ACL_ChanGroup::inherited_members(
    int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherited_members)
    return inherited_members_.Get(index);
  }
  inline void ACL_ChanGroup::set_inherited_members(int index,
      ::google::protobuf::uint32 value)
  {
    inherited_members_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherited_members)
  }
  inline void ACL_ChanGroup::add_inherited_members(::google::protobuf::uint32
      value)
  {
    inherited_members_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.inherited_members)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  ACL_ChanGroup::inherited_members() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.inherited_members)
    return inherited_members_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  ACL_ChanGroup::mutable_inherited_members()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.inherited_members)
    return &inherited_members_;
  }

// -------------------------------------------------------------------

// ACL_ChanACL

// optional bool apply_here = 1 [default = true];
  inline bool ACL_ChanACL::has_apply_here() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void ACL_ChanACL::set_has_apply_here()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void ACL_ChanACL::clear_has_apply_here()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void ACL_ChanACL::clear_apply_here()
  {
    apply_here_ = true;
    clear_has_apply_here();
  }
  inline bool ACL_ChanACL::apply_here() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.apply_here)
    return apply_here_;
  }
  inline void ACL_ChanACL::set_apply_here(bool value)
  {
    set_has_apply_here();
    apply_here_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.apply_here)
  }

// optional bool apply_subs = 2 [default = true];
  inline bool ACL_ChanACL::has_apply_subs() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void ACL_ChanACL::set_has_apply_subs()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void ACL_ChanACL::clear_has_apply_subs()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void ACL_ChanACL::clear_apply_subs()
  {
    apply_subs_ = true;
    clear_has_apply_subs();
  }
  inline bool ACL_ChanACL::apply_subs() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.apply_subs)
    return apply_subs_;
  }
  inline void ACL_ChanACL::set_apply_subs(bool value)
  {
    set_has_apply_subs();
    apply_subs_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.apply_subs)
  }

// optional bool inherited = 3 [default = true];
  inline bool ACL_ChanACL::has_inherited() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void ACL_ChanACL::set_has_inherited()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void ACL_ChanACL::clear_has_inherited()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void ACL_ChanACL::clear_inherited()
  {
    inherited_ = true;
    clear_has_inherited();
  }
  inline bool ACL_ChanACL::inherited() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.inherited)
    return inherited_;
  }
  inline void ACL_ChanACL::set_inherited(bool value)
  {
    set_has_inherited();
    inherited_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.inherited)
  }

// optional uint32 user_id = 4;
  inline bool ACL_ChanACL::has_user_id() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void ACL_ChanACL::set_has_user_id()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void ACL_ChanACL::clear_has_user_id()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void ACL_ChanACL::clear_user_id()
  {
    user_id_ = 0u;
    clear_has_user_id();
  }
  inline ::google::protobuf::uint32 ACL_ChanACL::user_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.user_id)
    return user_id_;
  }
  inline void ACL_ChanACL::set_user_id(::google::protobuf::uint32 value)
  {
    set_has_user_id();
    user_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.user_id)
  }

// optional string group = 5;
  inline bool ACL_ChanACL::has_group() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void ACL_ChanACL::set_has_group()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void ACL_ChanACL::clear_has_group()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void ACL_ChanACL::clear_group()
  {
    if (group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_->clear();
      }
    clear_has_group();
  }
  inline const ::std::string& ACL_ChanACL::group() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.group)
    return *group_;
  }
  inline void ACL_ChanACL::set_group(const ::std::string& value)
  {
    set_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_ = new ::std::string;
      }
    group_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.group)
  }
  inline void ACL_ChanACL::set_group(const char* value)
  {
    set_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_ = new ::std::string;
      }
    group_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ACL.ChanACL.group)
  }
  inline void ACL_ChanACL::set_group(const char* value, size_t size)
  {
    set_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_ = new ::std::string;
      }
    group_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ACL.ChanACL.group)
  }
  inline ::std::string* ACL_ChanACL::mutable_group()
  {
    set_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.ChanACL.group)
    return group_;
  }
  inline ::std::string* ACL_ChanACL::release_group()
  {
    clear_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = group_;
        group_ = const_cast< ::std::string*>
                 (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ACL_ChanACL::set_allocated_group(::std::string* group)
  {
    if (group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete group_;
      }
    if (group)
      {
        set_has_group();
        group_ = group;
      }
    else
      {
        clear_has_group();
        group_ = const_cast< ::std::string*>
                 (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ACL.ChanACL.group)
  }

// optional uint32 grant = 6;
  inline bool ACL_ChanACL::has_grant() const
  {
    return (_has_bits_[0] & 0x00000020u) != 0;
  }
  inline void ACL_ChanACL::set_has_grant()
  {
    _has_bits_[0] |= 0x00000020u;
  }
  inline void ACL_ChanACL::clear_has_grant()
  {
    _has_bits_[0] &= ~0x00000020u;
  }
  inline void ACL_ChanACL::clear_grant()
  {
    grant_ = 0u;
    clear_has_grant();
  }
  inline ::google::protobuf::uint32 ACL_ChanACL::grant() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.grant)
    return grant_;
  }
  inline void ACL_ChanACL::set_grant(::google::protobuf::uint32 value)
  {
    set_has_grant();
    grant_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.grant)
  }

// optional uint32 deny = 7;
  inline bool ACL_ChanACL::has_deny() const
  {
    return (_has_bits_[0] & 0x00000040u) != 0;
  }
  inline void ACL_ChanACL::set_has_deny()
  {
    _has_bits_[0] |= 0x00000040u;
  }
  inline void ACL_ChanACL::clear_has_deny()
  {
    _has_bits_[0] &= ~0x00000040u;
  }
  inline void ACL_ChanACL::clear_deny()
  {
    deny_ = 0u;
    clear_has_deny();
  }
  inline ::google::protobuf::uint32 ACL_ChanACL::deny() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.deny)
    return deny_;
  }
  inline void ACL_ChanACL::set_deny(::google::protobuf::uint32 value)
  {
    set_has_deny();
    deny_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.deny)
  }

// -------------------------------------------------------------------

// ACL

// required uint32 channel_id = 1;
  inline bool ACL::has_channel_id() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void ACL::set_has_channel_id()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void ACL::clear_has_channel_id()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void ACL::clear_channel_id()
  {
    channel_id_ = 0u;
    clear_has_channel_id();
  }
  inline ::google::protobuf::uint32 ACL::channel_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.channel_id)
    return channel_id_;
  }
  inline void ACL::set_channel_id(::google::protobuf::uint32 value)
  {
    set_has_channel_id();
    channel_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.channel_id)
  }

// optional bool inherit_acls = 2 [default = true];
  inline bool ACL::has_inherit_acls() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void ACL::set_has_inherit_acls()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void ACL::clear_has_inherit_acls()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void ACL::clear_inherit_acls()
  {
    inherit_acls_ = true;
    clear_has_inherit_acls();
  }
  inline bool ACL::inherit_acls() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.inherit_acls)
    return inherit_acls_;
  }
  inline void ACL::set_inherit_acls(bool value)
  {
    set_has_inherit_acls();
    inherit_acls_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.inherit_acls)
  }

// repeated .MumbleProto.ACL.ChanGroup groups = 3;
  inline int ACL::groups_size() const
  {
    return groups_.size();
  }
  inline void ACL::clear_groups()
  {
    groups_.Clear();
  }
  inline const ::MumbleProto::ACL_ChanGroup& ACL::groups(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.groups)
    return groups_.Get(index);
  }
  inline ::MumbleProto::ACL_ChanGroup* ACL::mutable_groups(int index)
  {
    // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.groups)
    return groups_.Mutable(index);
  }
  inline ::MumbleProto::ACL_ChanGroup* ACL::add_groups()
  {
    // @@protoc_insertion_point(field_add:MumbleProto.ACL.groups)
    return groups_.Add();
  }
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
  ACL::groups() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.ACL.groups)
    return groups_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
  ACL::mutable_groups()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.groups)
    return &groups_;
  }

// repeated .MumbleProto.ACL.ChanACL acls = 4;
  inline int ACL::acls_size() const
  {
    return acls_.size();
  }
  inline void ACL::clear_acls()
  {
    acls_.Clear();
  }
  inline const ::MumbleProto::ACL_ChanACL& ACL::acls(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.acls)
    return acls_.Get(index);
  }
  inline ::MumbleProto::ACL_ChanACL* ACL::mutable_acls(int index)
  {
    // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.acls)
    return acls_.Mutable(index);
  }
  inline ::MumbleProto::ACL_ChanACL* ACL::add_acls()
  {
    // @@protoc_insertion_point(field_add:MumbleProto.ACL.acls)
    return acls_.Add();
  }
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
  ACL::acls() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.ACL.acls)
    return acls_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
  ACL::mutable_acls()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.acls)
    return &acls_;
  }

// optional bool query = 5 [default = false];
  inline bool ACL::has_query() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void ACL::set_has_query()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void ACL::clear_has_query()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void ACL::clear_query()
  {
    query_ = false;
    clear_has_query();
  }
  inline bool ACL::query() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ACL.query)
    return query_;
  }
  inline void ACL::set_query(bool value)
  {
    set_has_query();
    query_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ACL.query)
  }

// -------------------------------------------------------------------

// QueryUsers

// repeated uint32 ids = 1;
  inline int QueryUsers::ids_size() const
  {
    return ids_.size();
  }
  inline void QueryUsers::clear_ids()
  {
    ids_.Clear();
  }
  inline ::google::protobuf::uint32 QueryUsers::ids(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.QueryUsers.ids)
    return ids_.Get(index);
  }
  inline void QueryUsers::set_ids(int index, ::google::protobuf::uint32 value)
  {
    ids_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.ids)
  }
  inline void QueryUsers::add_ids(::google::protobuf::uint32 value)
  {
    ids_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.ids)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  QueryUsers::ids() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.QueryUsers.ids)
    return ids_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  QueryUsers::mutable_ids()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.QueryUsers.ids)
    return &ids_;
  }

// repeated string names = 2;
  inline int QueryUsers::names_size() const
  {
    return names_.size();
  }
  inline void QueryUsers::clear_names()
  {
    names_.Clear();
  }
  inline const ::std::string& QueryUsers::names(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.QueryUsers.names)
    return names_.Get(index);
  }
  inline ::std::string* QueryUsers::mutable_names(int index)
  {
    // @@protoc_insertion_point(field_mutable:MumbleProto.QueryUsers.names)
    return names_.Mutable(index);
  }
  inline void QueryUsers::set_names(int index, const ::std::string& value)
  {
    // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.names)
    names_.Mutable(index)->assign(value);
  }
  inline void QueryUsers::set_names(int index, const char* value)
  {
    names_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.QueryUsers.names)
  }
  inline void QueryUsers::set_names(int index, const char* value, size_t size)
  {
    names_.Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.QueryUsers.names)
  }
  inline ::std::string* QueryUsers::add_names()
  {
    return names_.Add();
  }
  inline void QueryUsers::add_names(const ::std::string& value)
  {
    names_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.names)
  }
  inline void QueryUsers::add_names(const char* value)
  {
    names_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:MumbleProto.QueryUsers.names)
  }
  inline void QueryUsers::add_names(const char* value, size_t size)
  {
    names_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:MumbleProto.QueryUsers.names)
  }
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
  QueryUsers::names() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.QueryUsers.names)
    return names_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::std::string>*
  QueryUsers::mutable_names()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.QueryUsers.names)
    return &names_;
  }

// -------------------------------------------------------------------

// CryptSetup

// optional bytes key = 1;
  inline bool CryptSetup::has_key() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void CryptSetup::set_has_key()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void CryptSetup::clear_has_key()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void CryptSetup::clear_key()
  {
    if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        key_->clear();
      }
    clear_has_key();
  }
  inline const ::std::string& CryptSetup::key() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.key)
    return *key_;
  }
  inline void CryptSetup::set_key(const ::std::string& value)
  {
    set_has_key();
    if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        key_ = new ::std::string;
      }
    key_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.key)
  }
  inline void CryptSetup::set_key(const char* value)
  {
    set_has_key();
    if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        key_ = new ::std::string;
      }
    key_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.key)
  }
  inline void CryptSetup::set_key(const void* value, size_t size)
  {
    set_has_key();
    if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        key_ = new ::std::string;
      }
    key_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.key)
  }
  inline ::std::string* CryptSetup::mutable_key()
  {
    set_has_key();
    if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        key_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.key)
    return key_;
  }
  inline ::std::string* CryptSetup::release_key()
  {
    clear_has_key();
    if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = key_;
        key_ = const_cast< ::std::string*>
               (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void CryptSetup::set_allocated_key(::std::string* key)
  {
    if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete key_;
      }
    if (key)
      {
        set_has_key();
        key_ = key;
      }
    else
      {
        clear_has_key();
        key_ = const_cast< ::std::string*>
               (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.key)
  }

// optional bytes client_nonce = 2;
  inline bool CryptSetup::has_client_nonce() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void CryptSetup::set_has_client_nonce()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void CryptSetup::clear_has_client_nonce()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void CryptSetup::clear_client_nonce()
  {
    if (client_nonce_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        client_nonce_->clear();
      }
    clear_has_client_nonce();
  }
  inline const ::std::string& CryptSetup::client_nonce() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.client_nonce)
    return *client_nonce_;
  }
  inline void CryptSetup::set_client_nonce(const ::std::string& value)
  {
    set_has_client_nonce();
    if (client_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        client_nonce_ = new ::std::string;
      }
    client_nonce_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.client_nonce)
  }
  inline void CryptSetup::set_client_nonce(const char* value)
  {
    set_has_client_nonce();
    if (client_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        client_nonce_ = new ::std::string;
      }
    client_nonce_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.client_nonce)
  }
  inline void CryptSetup::set_client_nonce(const void* value, size_t size)
  {
    set_has_client_nonce();
    if (client_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        client_nonce_ = new ::std::string;
      }
    client_nonce_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.client_nonce)
  }
  inline ::std::string* CryptSetup::mutable_client_nonce()
  {
    set_has_client_nonce();
    if (client_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        client_nonce_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.client_nonce)
    return client_nonce_;
  }
  inline ::std::string* CryptSetup::release_client_nonce()
  {
    clear_has_client_nonce();
    if (client_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = client_nonce_;
        client_nonce_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void CryptSetup::set_allocated_client_nonce(::std::string* client_nonce)
  {
    if (client_nonce_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete client_nonce_;
      }
    if (client_nonce)
      {
        set_has_client_nonce();
        client_nonce_ = client_nonce;
      }
    else
      {
        clear_has_client_nonce();
        client_nonce_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.client_nonce)
  }

// optional bytes server_nonce = 3;
  inline bool CryptSetup::has_server_nonce() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void CryptSetup::set_has_server_nonce()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void CryptSetup::clear_has_server_nonce()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void CryptSetup::clear_server_nonce()
  {
    if (server_nonce_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        server_nonce_->clear();
      }
    clear_has_server_nonce();
  }
  inline const ::std::string& CryptSetup::server_nonce() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.server_nonce)
    return *server_nonce_;
  }
  inline void CryptSetup::set_server_nonce(const ::std::string& value)
  {
    set_has_server_nonce();
    if (server_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        server_nonce_ = new ::std::string;
      }
    server_nonce_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.server_nonce)
  }
  inline void CryptSetup::set_server_nonce(const char* value)
  {
    set_has_server_nonce();
    if (server_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        server_nonce_ = new ::std::string;
      }
    server_nonce_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.server_nonce)
  }
  inline void CryptSetup::set_server_nonce(const void* value, size_t size)
  {
    set_has_server_nonce();
    if (server_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        server_nonce_ = new ::std::string;
      }
    server_nonce_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.server_nonce)
  }
  inline ::std::string* CryptSetup::mutable_server_nonce()
  {
    set_has_server_nonce();
    if (server_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        server_nonce_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.server_nonce)
    return server_nonce_;
  }
  inline ::std::string* CryptSetup::release_server_nonce()
  {
    clear_has_server_nonce();
    if (server_nonce_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = server_nonce_;
        server_nonce_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void CryptSetup::set_allocated_server_nonce(::std::string* server_nonce)
  {
    if (server_nonce_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete server_nonce_;
      }
    if (server_nonce)
      {
        set_has_server_nonce();
        server_nonce_ = server_nonce;
      }
    else
      {
        clear_has_server_nonce();
        server_nonce_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.server_nonce)
  }

// -------------------------------------------------------------------

// ContextActionModify

// required string action = 1;
  inline bool ContextActionModify::has_action() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void ContextActionModify::set_has_action()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void ContextActionModify::clear_has_action()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void ContextActionModify::clear_action()
  {
    if (action_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_->clear();
      }
    clear_has_action();
  }
  inline const ::std::string& ContextActionModify::action() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.action)
    return *action_;
  }
  inline void ContextActionModify::set_action(const ::std::string& value)
  {
    set_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_ = new ::std::string;
      }
    action_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.action)
  }
  inline void ContextActionModify::set_action(const char* value)
  {
    set_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_ = new ::std::string;
      }
    action_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ContextActionModify.action)
  }
  inline void ContextActionModify::set_action(const char* value, size_t size)
  {
    set_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_ = new ::std::string;
      }
    action_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextActionModify.action)
  }
  inline ::std::string* ContextActionModify::mutable_action()
  {
    set_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ContextActionModify.action)
    return action_;
  }
  inline ::std::string* ContextActionModify::release_action()
  {
    clear_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = action_;
        action_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ContextActionModify::set_allocated_action(::std::string* action)
  {
    if (action_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete action_;
      }
    if (action)
      {
        set_has_action();
        action_ = action;
      }
    else
      {
        clear_has_action();
        action_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextActionModify.action)
  }

// optional string text = 2;
  inline bool ContextActionModify::has_text() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void ContextActionModify::set_has_text()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void ContextActionModify::clear_has_text()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void ContextActionModify::clear_text()
  {
    if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        text_->clear();
      }
    clear_has_text();
  }
  inline const ::std::string& ContextActionModify::text() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.text)
    return *text_;
  }
  inline void ContextActionModify::set_text(const ::std::string& value)
  {
    set_has_text();
    if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        text_ = new ::std::string;
      }
    text_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.text)
  }
  inline void ContextActionModify::set_text(const char* value)
  {
    set_has_text();
    if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        text_ = new ::std::string;
      }
    text_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ContextActionModify.text)
  }
  inline void ContextActionModify::set_text(const char* value, size_t size)
  {
    set_has_text();
    if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        text_ = new ::std::string;
      }
    text_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextActionModify.text)
  }
  inline ::std::string* ContextActionModify::mutable_text()
  {
    set_has_text();
    if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        text_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ContextActionModify.text)
    return text_;
  }
  inline ::std::string* ContextActionModify::release_text()
  {
    clear_has_text();
    if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = text_;
        text_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ContextActionModify::set_allocated_text(::std::string* text)
  {
    if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete text_;
      }
    if (text)
      {
        set_has_text();
        text_ = text;
      }
    else
      {
        clear_has_text();
        text_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextActionModify.text)
  }

// optional uint32 context = 3;
  inline bool ContextActionModify::has_context() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void ContextActionModify::set_has_context()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void ContextActionModify::clear_has_context()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void ContextActionModify::clear_context()
  {
    context_ = 0u;
    clear_has_context();
  }
  inline ::google::protobuf::uint32 ContextActionModify::context() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.context)
    return context_;
  }
  inline void ContextActionModify::set_context(::google::protobuf::uint32 value)
  {
    set_has_context();
    context_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.context)
  }

// optional .MumbleProto.ContextActionModify.Operation operation = 4;
  inline bool ContextActionModify::has_operation() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void ContextActionModify::set_has_operation()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void ContextActionModify::clear_has_operation()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void ContextActionModify::clear_operation()
  {
    operation_ = 0;
    clear_has_operation();
  }
  inline ::MumbleProto::ContextActionModify_Operation
  ContextActionModify::operation() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.operation)
    return static_cast< ::MumbleProto::ContextActionModify_Operation >(operation_);
  }
  inline void ContextActionModify::set_operation(
    ::MumbleProto::ContextActionModify_Operation value)
  {
    assert(::MumbleProto::ContextActionModify_Operation_IsValid(value));
    set_has_operation();
    operation_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.operation)
  }

// -------------------------------------------------------------------

// ContextAction

// optional uint32 session = 1;
  inline bool ContextAction::has_session() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void ContextAction::set_has_session()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void ContextAction::clear_has_session()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void ContextAction::clear_session()
  {
    session_ = 0u;
    clear_has_session();
  }
  inline ::google::protobuf::uint32 ContextAction::session() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.session)
    return session_;
  }
  inline void ContextAction::set_session(::google::protobuf::uint32 value)
  {
    set_has_session();
    session_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.session)
  }

// optional uint32 channel_id = 2;
  inline bool ContextAction::has_channel_id() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void ContextAction::set_has_channel_id()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void ContextAction::clear_has_channel_id()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void ContextAction::clear_channel_id()
  {
    channel_id_ = 0u;
    clear_has_channel_id();
  }
  inline ::google::protobuf::uint32 ContextAction::channel_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.channel_id)
    return channel_id_;
  }
  inline void ContextAction::set_channel_id(::google::protobuf::uint32 value)
  {
    set_has_channel_id();
    channel_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.channel_id)
  }

// required string action = 3;
  inline bool ContextAction::has_action() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void ContextAction::set_has_action()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void ContextAction::clear_has_action()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void ContextAction::clear_action()
  {
    if (action_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_->clear();
      }
    clear_has_action();
  }
  inline const ::std::string& ContextAction::action() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.action)
    return *action_;
  }
  inline void ContextAction::set_action(const ::std::string& value)
  {
    set_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_ = new ::std::string;
      }
    action_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.action)
  }
  inline void ContextAction::set_action(const char* value)
  {
    set_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_ = new ::std::string;
      }
    action_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ContextAction.action)
  }
  inline void ContextAction::set_action(const char* value, size_t size)
  {
    set_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_ = new ::std::string;
      }
    action_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextAction.action)
  }
  inline ::std::string* ContextAction::mutable_action()
  {
    set_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        action_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ContextAction.action)
    return action_;
  }
  inline ::std::string* ContextAction::release_action()
  {
    clear_has_action();
    if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = action_;
        action_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ContextAction::set_allocated_action(::std::string* action)
  {
    if (action_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete action_;
      }
    if (action)
      {
        set_has_action();
        action_ = action;
      }
    else
      {
        clear_has_action();
        action_ = const_cast< ::std::string*>
                  (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextAction.action)
  }

// -------------------------------------------------------------------

// UserList_User

// required uint32 user_id = 1;
  inline bool UserList_User::has_user_id() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void UserList_User::set_has_user_id()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void UserList_User::clear_has_user_id()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void UserList_User::clear_user_id()
  {
    user_id_ = 0u;
    clear_has_user_id();
  }
  inline ::google::protobuf::uint32 UserList_User::user_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.user_id)
    return user_id_;
  }
  inline void UserList_User::set_user_id(::google::protobuf::uint32 value)
  {
    set_has_user_id();
    user_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.user_id)
  }

// optional string name = 2;
  inline bool UserList_User::has_name() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void UserList_User::set_has_name()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void UserList_User::clear_has_name()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void UserList_User::clear_name()
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_->clear();
      }
    clear_has_name();
  }
  inline const ::std::string& UserList_User::name() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.name)
    return *name_;
  }
  inline void UserList_User::set_name(const ::std::string& value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.name)
  }
  inline void UserList_User::set_name(const char* value)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserList.User.name)
  }
  inline void UserList_User::set_name(const char* value, size_t size)
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    name_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserList.User.name)
  }
  inline ::std::string* UserList_User::mutable_name()
  {
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        name_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.User.name)
    return name_;
  }
  inline ::std::string* UserList_User::release_name()
  {
    clear_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = name_;
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserList_User::set_allocated_name(::std::string* name)
  {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete name_;
      }
    if (name)
      {
        set_has_name();
        name_ = name;
      }
    else
      {
        clear_has_name();
        name_ = const_cast< ::std::string*>
                (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserList.User.name)
  }

// optional string last_seen = 3;
  inline bool UserList_User::has_last_seen() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void UserList_User::set_has_last_seen()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void UserList_User::clear_has_last_seen()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void UserList_User::clear_last_seen()
  {
    if (last_seen_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        last_seen_->clear();
      }
    clear_has_last_seen();
  }
  inline const ::std::string& UserList_User::last_seen() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.last_seen)
    return *last_seen_;
  }
  inline void UserList_User::set_last_seen(const ::std::string& value)
  {
    set_has_last_seen();
    if (last_seen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        last_seen_ = new ::std::string;
      }
    last_seen_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.last_seen)
  }
  inline void UserList_User::set_last_seen(const char* value)
  {
    set_has_last_seen();
    if (last_seen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        last_seen_ = new ::std::string;
      }
    last_seen_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserList.User.last_seen)
  }
  inline void UserList_User::set_last_seen(const char* value, size_t size)
  {
    set_has_last_seen();
    if (last_seen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        last_seen_ = new ::std::string;
      }
    last_seen_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserList.User.last_seen)
  }
  inline ::std::string* UserList_User::mutable_last_seen()
  {
    set_has_last_seen();
    if (last_seen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        last_seen_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.User.last_seen)
    return last_seen_;
  }
  inline ::std::string* UserList_User::release_last_seen()
  {
    clear_has_last_seen();
    if (last_seen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = last_seen_;
        last_seen_ = const_cast< ::std::string*>
                     (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserList_User::set_allocated_last_seen(::std::string* last_seen)
  {
    if (last_seen_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete last_seen_;
      }
    if (last_seen)
      {
        set_has_last_seen();
        last_seen_ = last_seen;
      }
    else
      {
        clear_has_last_seen();
        last_seen_ = const_cast< ::std::string*>
                     (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserList.User.last_seen)
  }

// optional uint32 last_channel = 4;
  inline bool UserList_User::has_last_channel() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void UserList_User::set_has_last_channel()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void UserList_User::clear_has_last_channel()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void UserList_User::clear_last_channel()
  {
    last_channel_ = 0u;
    clear_has_last_channel();
  }
  inline ::google::protobuf::uint32 UserList_User::last_channel() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.last_channel)
    return last_channel_;
  }
  inline void UserList_User::set_last_channel(::google::protobuf::uint32 value)
  {
    set_has_last_channel();
    last_channel_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.last_channel)
  }

// -------------------------------------------------------------------

// UserList

// repeated .MumbleProto.UserList.User users = 1;
  inline int UserList::users_size() const
  {
    return users_.size();
  }
  inline void UserList::clear_users()
  {
    users_.Clear();
  }
  inline const ::MumbleProto::UserList_User& UserList::users(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserList.users)
    return users_.Get(index);
  }
  inline ::MumbleProto::UserList_User* UserList::mutable_users(int index)
  {
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.users)
    return users_.Mutable(index);
  }
  inline ::MumbleProto::UserList_User* UserList::add_users()
  {
    // @@protoc_insertion_point(field_add:MumbleProto.UserList.users)
    return users_.Add();
  }
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >&
  UserList::users() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.UserList.users)
    return users_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >*
  UserList::mutable_users()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserList.users)
    return &users_;
  }

// -------------------------------------------------------------------

// VoiceTarget_Target

// repeated uint32 session = 1;
  inline int VoiceTarget_Target::session_size() const
  {
    return session_.size();
  }
  inline void VoiceTarget_Target::clear_session()
  {
    session_.Clear();
  }
  inline ::google::protobuf::uint32 VoiceTarget_Target::session(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.session)
    return session_.Get(index);
  }
  inline void VoiceTarget_Target::set_session(int index,
      ::google::protobuf::uint32 value)
  {
    session_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.session)
  }
  inline void VoiceTarget_Target::add_session(::google::protobuf::uint32 value)
  {
    session_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.VoiceTarget.Target.session)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  VoiceTarget_Target::session() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.VoiceTarget.Target.session)
    return session_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  VoiceTarget_Target::mutable_session()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.VoiceTarget.Target.session)
    return &session_;
  }

// optional uint32 channel_id = 2;
  inline bool VoiceTarget_Target::has_channel_id() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void VoiceTarget_Target::set_has_channel_id()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void VoiceTarget_Target::clear_has_channel_id()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void VoiceTarget_Target::clear_channel_id()
  {
    channel_id_ = 0u;
    clear_has_channel_id();
  }
  inline ::google::protobuf::uint32 VoiceTarget_Target::channel_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.channel_id)
    return channel_id_;
  }
  inline void VoiceTarget_Target::set_channel_id(::google::protobuf::uint32
      value)
  {
    set_has_channel_id();
    channel_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.channel_id)
  }

// optional string group = 3;
  inline bool VoiceTarget_Target::has_group() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void VoiceTarget_Target::set_has_group()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void VoiceTarget_Target::clear_has_group()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void VoiceTarget_Target::clear_group()
  {
    if (group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_->clear();
      }
    clear_has_group();
  }
  inline const ::std::string& VoiceTarget_Target::group() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.group)
    return *group_;
  }
  inline void VoiceTarget_Target::set_group(const ::std::string& value)
  {
    set_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_ = new ::std::string;
      }
    group_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.group)
  }
  inline void VoiceTarget_Target::set_group(const char* value)
  {
    set_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_ = new ::std::string;
      }
    group_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.VoiceTarget.Target.group)
  }
  inline void VoiceTarget_Target::set_group(const char* value, size_t size)
  {
    set_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_ = new ::std::string;
      }
    group_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.VoiceTarget.Target.group)
  }
  inline ::std::string* VoiceTarget_Target::mutable_group()
  {
    set_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        group_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.VoiceTarget.Target.group)
    return group_;
  }
  inline ::std::string* VoiceTarget_Target::release_group()
  {
    clear_has_group();
    if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = group_;
        group_ = const_cast< ::std::string*>
                 (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void VoiceTarget_Target::set_allocated_group(::std::string* group)
  {
    if (group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete group_;
      }
    if (group)
      {
        set_has_group();
        group_ = group;
      }
    else
      {
        clear_has_group();
        group_ = const_cast< ::std::string*>
                 (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.VoiceTarget.Target.group)
  }

// optional bool links = 4 [default = false];
  inline bool VoiceTarget_Target::has_links() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void VoiceTarget_Target::set_has_links()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void VoiceTarget_Target::clear_has_links()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void VoiceTarget_Target::clear_links()
  {
    links_ = false;
    clear_has_links();
  }
  inline bool VoiceTarget_Target::links() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.links)
    return links_;
  }
  inline void VoiceTarget_Target::set_links(bool value)
  {
    set_has_links();
    links_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.links)
  }

// optional bool children = 5 [default = false];
  inline bool VoiceTarget_Target::has_children() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void VoiceTarget_Target::set_has_children()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void VoiceTarget_Target::clear_has_children()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void VoiceTarget_Target::clear_children()
  {
    children_ = false;
    clear_has_children();
  }
  inline bool VoiceTarget_Target::children() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.children)
    return children_;
  }
  inline void VoiceTarget_Target::set_children(bool value)
  {
    set_has_children();
    children_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.children)
  }

// -------------------------------------------------------------------

// VoiceTarget

// optional uint32 id = 1;
  inline bool VoiceTarget::has_id() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void VoiceTarget::set_has_id()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void VoiceTarget::clear_has_id()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void VoiceTarget::clear_id()
  {
    id_ = 0u;
    clear_has_id();
  }
  inline ::google::protobuf::uint32 VoiceTarget::id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.id)
    return id_;
  }
  inline void VoiceTarget::set_id(::google::protobuf::uint32 value)
  {
    set_has_id();
    id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.id)
  }

// repeated .MumbleProto.VoiceTarget.Target targets = 2;
  inline int VoiceTarget::targets_size() const
  {
    return targets_.size();
  }
  inline void VoiceTarget::clear_targets()
  {
    targets_.Clear();
  }
  inline const ::MumbleProto::VoiceTarget_Target& VoiceTarget::targets(
    int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.targets)
    return targets_.Get(index);
  }
  inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::mutable_targets(
    int index)
  {
    // @@protoc_insertion_point(field_mutable:MumbleProto.VoiceTarget.targets)
    return targets_.Mutable(index);
  }
  inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::add_targets()
  {
    // @@protoc_insertion_point(field_add:MumbleProto.VoiceTarget.targets)
    return targets_.Add();
  }
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
  VoiceTarget::targets() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.VoiceTarget.targets)
    return targets_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
  VoiceTarget::mutable_targets()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.VoiceTarget.targets)
    return &targets_;
  }

// -------------------------------------------------------------------

// PermissionQuery

// optional uint32 channel_id = 1;
  inline bool PermissionQuery::has_channel_id() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void PermissionQuery::set_has_channel_id()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void PermissionQuery::clear_has_channel_id()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void PermissionQuery::clear_channel_id()
  {
    channel_id_ = 0u;
    clear_has_channel_id();
  }
  inline ::google::protobuf::uint32 PermissionQuery::channel_id() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.channel_id)
    return channel_id_;
  }
  inline void PermissionQuery::set_channel_id(::google::protobuf::uint32 value)
  {
    set_has_channel_id();
    channel_id_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.channel_id)
  }

// optional uint32 permissions = 2;
  inline bool PermissionQuery::has_permissions() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void PermissionQuery::set_has_permissions()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void PermissionQuery::clear_has_permissions()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void PermissionQuery::clear_permissions()
  {
    permissions_ = 0u;
    clear_has_permissions();
  }
  inline ::google::protobuf::uint32 PermissionQuery::permissions() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.permissions)
    return permissions_;
  }
  inline void PermissionQuery::set_permissions(::google::protobuf::uint32 value)
  {
    set_has_permissions();
    permissions_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.permissions)
  }

// optional bool flush = 3 [default = false];
  inline bool PermissionQuery::has_flush() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void PermissionQuery::set_has_flush()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void PermissionQuery::clear_has_flush()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void PermissionQuery::clear_flush()
  {
    flush_ = false;
    clear_has_flush();
  }
  inline bool PermissionQuery::flush() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.flush)
    return flush_;
  }
  inline void PermissionQuery::set_flush(bool value)
  {
    set_has_flush();
    flush_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.flush)
  }

// -------------------------------------------------------------------

// CodecVersion

// required int32 alpha = 1;
  inline bool CodecVersion::has_alpha() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void CodecVersion::set_has_alpha()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void CodecVersion::clear_has_alpha()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void CodecVersion::clear_alpha()
  {
    alpha_ = 0;
    clear_has_alpha();
  }
  inline ::google::protobuf::int32 CodecVersion::alpha() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.alpha)
    return alpha_;
  }
  inline void CodecVersion::set_alpha(::google::protobuf::int32 value)
  {
    set_has_alpha();
    alpha_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.alpha)
  }

// required int32 beta = 2;
  inline bool CodecVersion::has_beta() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void CodecVersion::set_has_beta()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void CodecVersion::clear_has_beta()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void CodecVersion::clear_beta()
  {
    beta_ = 0;
    clear_has_beta();
  }
  inline ::google::protobuf::int32 CodecVersion::beta() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.beta)
    return beta_;
  }
  inline void CodecVersion::set_beta(::google::protobuf::int32 value)
  {
    set_has_beta();
    beta_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.beta)
  }

// required bool prefer_alpha = 3 [default = true];
  inline bool CodecVersion::has_prefer_alpha() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void CodecVersion::set_has_prefer_alpha()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void CodecVersion::clear_has_prefer_alpha()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void CodecVersion::clear_prefer_alpha()
  {
    prefer_alpha_ = true;
    clear_has_prefer_alpha();
  }
  inline bool CodecVersion::prefer_alpha() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.prefer_alpha)
    return prefer_alpha_;
  }
  inline void CodecVersion::set_prefer_alpha(bool value)
  {
    set_has_prefer_alpha();
    prefer_alpha_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.prefer_alpha)
  }

// optional bool opus = 4 [default = false];
  inline bool CodecVersion::has_opus() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void CodecVersion::set_has_opus()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void CodecVersion::clear_has_opus()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void CodecVersion::clear_opus()
  {
    opus_ = false;
    clear_has_opus();
  }
  inline bool CodecVersion::opus() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.opus)
    return opus_;
  }
  inline void CodecVersion::set_opus(bool value)
  {
    set_has_opus();
    opus_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.opus)
  }

// -------------------------------------------------------------------

// UserStats_Stats

// optional uint32 good = 1;
  inline bool UserStats_Stats::has_good() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void UserStats_Stats::set_has_good()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void UserStats_Stats::clear_has_good()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void UserStats_Stats::clear_good()
  {
    good_ = 0u;
    clear_has_good();
  }
  inline ::google::protobuf::uint32 UserStats_Stats::good() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.good)
    return good_;
  }
  inline void UserStats_Stats::set_good(::google::protobuf::uint32 value)
  {
    set_has_good();
    good_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.good)
  }

// optional uint32 late = 2;
  inline bool UserStats_Stats::has_late() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void UserStats_Stats::set_has_late()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void UserStats_Stats::clear_has_late()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void UserStats_Stats::clear_late()
  {
    late_ = 0u;
    clear_has_late();
  }
  inline ::google::protobuf::uint32 UserStats_Stats::late() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.late)
    return late_;
  }
  inline void UserStats_Stats::set_late(::google::protobuf::uint32 value)
  {
    set_has_late();
    late_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.late)
  }

// optional uint32 lost = 3;
  inline bool UserStats_Stats::has_lost() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void UserStats_Stats::set_has_lost()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void UserStats_Stats::clear_has_lost()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void UserStats_Stats::clear_lost()
  {
    lost_ = 0u;
    clear_has_lost();
  }
  inline ::google::protobuf::uint32 UserStats_Stats::lost() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.lost)
    return lost_;
  }
  inline void UserStats_Stats::set_lost(::google::protobuf::uint32 value)
  {
    set_has_lost();
    lost_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.lost)
  }

// optional uint32 resync = 4;
  inline bool UserStats_Stats::has_resync() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void UserStats_Stats::set_has_resync()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void UserStats_Stats::clear_has_resync()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void UserStats_Stats::clear_resync()
  {
    resync_ = 0u;
    clear_has_resync();
  }
  inline ::google::protobuf::uint32 UserStats_Stats::resync() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.resync)
    return resync_;
  }
  inline void UserStats_Stats::set_resync(::google::protobuf::uint32 value)
  {
    set_has_resync();
    resync_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.resync)
  }

// -------------------------------------------------------------------

// UserStats

// optional uint32 session = 1;
  inline bool UserStats::has_session() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void UserStats::set_has_session()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void UserStats::clear_has_session()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void UserStats::clear_session()
  {
    session_ = 0u;
    clear_has_session();
  }
  inline ::google::protobuf::uint32 UserStats::session() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.session)
    return session_;
  }
  inline void UserStats::set_session(::google::protobuf::uint32 value)
  {
    set_has_session();
    session_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.session)
  }

// optional bool stats_only = 2 [default = false];
  inline bool UserStats::has_stats_only() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void UserStats::set_has_stats_only()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void UserStats::clear_has_stats_only()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void UserStats::clear_stats_only()
  {
    stats_only_ = false;
    clear_has_stats_only();
  }
  inline bool UserStats::stats_only() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.stats_only)
    return stats_only_;
  }
  inline void UserStats::set_stats_only(bool value)
  {
    set_has_stats_only();
    stats_only_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.stats_only)
  }

// repeated bytes certificates = 3;
  inline int UserStats::certificates_size() const
  {
    return certificates_.size();
  }
  inline void UserStats::clear_certificates()
  {
    certificates_.Clear();
  }
  inline const ::std::string& UserStats::certificates(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.certificates)
    return certificates_.Get(index);
  }
  inline ::std::string* UserStats::mutable_certificates(int index)
  {
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.certificates)
    return certificates_.Mutable(index);
  }
  inline void UserStats::set_certificates(int index, const ::std::string& value)
  {
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.certificates)
    certificates_.Mutable(index)->assign(value);
  }
  inline void UserStats::set_certificates(int index, const char* value)
  {
    certificates_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserStats.certificates)
  }
  inline void UserStats::set_certificates(int index, const void* value,
                                          size_t size)
  {
    certificates_.Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserStats.certificates)
  }
  inline ::std::string* UserStats::add_certificates()
  {
    return certificates_.Add();
  }
  inline void UserStats::add_certificates(const ::std::string& value)
  {
    certificates_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:MumbleProto.UserStats.certificates)
  }
  inline void UserStats::add_certificates(const char* value)
  {
    certificates_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:MumbleProto.UserStats.certificates)
  }
  inline void UserStats::add_certificates(const void* value, size_t size)
  {
    certificates_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:MumbleProto.UserStats.certificates)
  }
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
  UserStats::certificates() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.UserStats.certificates)
    return certificates_;
  }
  inline ::google::protobuf::RepeatedPtrField< ::std::string>*
  UserStats::mutable_certificates()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserStats.certificates)
    return &certificates_;
  }

// optional .MumbleProto.UserStats.Stats from_client = 4;
  inline bool UserStats::has_from_client() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void UserStats::set_has_from_client()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void UserStats::clear_has_from_client()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void UserStats::clear_from_client()
  {
    if (from_client_ != NULL) from_client_->::MumbleProto::UserStats_Stats::Clear();
    clear_has_from_client();
  }
  inline const ::MumbleProto::UserStats_Stats& UserStats::from_client() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.from_client)
    return from_client_ != NULL ? *from_client_ : *default_instance_->from_client_;
  }
  inline ::MumbleProto::UserStats_Stats* UserStats::mutable_from_client()
  {
    set_has_from_client();
    if (from_client_ == NULL) from_client_ = new ::MumbleProto::UserStats_Stats;
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.from_client)
    return from_client_;
  }
  inline ::MumbleProto::UserStats_Stats* UserStats::release_from_client()
  {
    clear_has_from_client();
    ::MumbleProto::UserStats_Stats* temp = from_client_;
    from_client_ = NULL;
    return temp;
  }
  inline void UserStats::set_allocated_from_client(::MumbleProto::UserStats_Stats*
      from_client)
  {
    delete from_client_;
    from_client_ = from_client;
    if (from_client)
      {
        set_has_from_client();
      }
    else
      {
        clear_has_from_client();
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.from_client)
  }

// optional .MumbleProto.UserStats.Stats from_server = 5;
  inline bool UserStats::has_from_server() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void UserStats::set_has_from_server()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void UserStats::clear_has_from_server()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void UserStats::clear_from_server()
  {
    if (from_server_ != NULL) from_server_->::MumbleProto::UserStats_Stats::Clear();
    clear_has_from_server();
  }
  inline const ::MumbleProto::UserStats_Stats& UserStats::from_server() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.from_server)
    return from_server_ != NULL ? *from_server_ : *default_instance_->from_server_;
  }
  inline ::MumbleProto::UserStats_Stats* UserStats::mutable_from_server()
  {
    set_has_from_server();
    if (from_server_ == NULL) from_server_ = new ::MumbleProto::UserStats_Stats;
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.from_server)
    return from_server_;
  }
  inline ::MumbleProto::UserStats_Stats* UserStats::release_from_server()
  {
    clear_has_from_server();
    ::MumbleProto::UserStats_Stats* temp = from_server_;
    from_server_ = NULL;
    return temp;
  }
  inline void UserStats::set_allocated_from_server(::MumbleProto::UserStats_Stats*
      from_server)
  {
    delete from_server_;
    from_server_ = from_server;
    if (from_server)
      {
        set_has_from_server();
      }
    else
      {
        clear_has_from_server();
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.from_server)
  }

// optional uint32 udp_packets = 6;
  inline bool UserStats::has_udp_packets() const
  {
    return (_has_bits_[0] & 0x00000020u) != 0;
  }
  inline void UserStats::set_has_udp_packets()
  {
    _has_bits_[0] |= 0x00000020u;
  }
  inline void UserStats::clear_has_udp_packets()
  {
    _has_bits_[0] &= ~0x00000020u;
  }
  inline void UserStats::clear_udp_packets()
  {
    udp_packets_ = 0u;
    clear_has_udp_packets();
  }
  inline ::google::protobuf::uint32 UserStats::udp_packets() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_packets)
    return udp_packets_;
  }
  inline void UserStats::set_udp_packets(::google::protobuf::uint32 value)
  {
    set_has_udp_packets();
    udp_packets_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_packets)
  }

// optional uint32 tcp_packets = 7;
  inline bool UserStats::has_tcp_packets() const
  {
    return (_has_bits_[0] & 0x00000040u) != 0;
  }
  inline void UserStats::set_has_tcp_packets()
  {
    _has_bits_[0] |= 0x00000040u;
  }
  inline void UserStats::clear_has_tcp_packets()
  {
    _has_bits_[0] &= ~0x00000040u;
  }
  inline void UserStats::clear_tcp_packets()
  {
    tcp_packets_ = 0u;
    clear_has_tcp_packets();
  }
  inline ::google::protobuf::uint32 UserStats::tcp_packets() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_packets)
    return tcp_packets_;
  }
  inline void UserStats::set_tcp_packets(::google::protobuf::uint32 value)
  {
    set_has_tcp_packets();
    tcp_packets_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_packets)
  }

// optional float udp_ping_avg = 8;
  inline bool UserStats::has_udp_ping_avg() const
  {
    return (_has_bits_[0] & 0x00000080u) != 0;
  }
  inline void UserStats::set_has_udp_ping_avg()
  {
    _has_bits_[0] |= 0x00000080u;
  }
  inline void UserStats::clear_has_udp_ping_avg()
  {
    _has_bits_[0] &= ~0x00000080u;
  }
  inline void UserStats::clear_udp_ping_avg()
  {
    udp_ping_avg_ = 0;
    clear_has_udp_ping_avg();
  }
  inline float UserStats::udp_ping_avg() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_ping_avg)
    return udp_ping_avg_;
  }
  inline void UserStats::set_udp_ping_avg(float value)
  {
    set_has_udp_ping_avg();
    udp_ping_avg_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_ping_avg)
  }

// optional float udp_ping_var = 9;
  inline bool UserStats::has_udp_ping_var() const
  {
    return (_has_bits_[0] & 0x00000100u) != 0;
  }
  inline void UserStats::set_has_udp_ping_var()
  {
    _has_bits_[0] |= 0x00000100u;
  }
  inline void UserStats::clear_has_udp_ping_var()
  {
    _has_bits_[0] &= ~0x00000100u;
  }
  inline void UserStats::clear_udp_ping_var()
  {
    udp_ping_var_ = 0;
    clear_has_udp_ping_var();
  }
  inline float UserStats::udp_ping_var() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_ping_var)
    return udp_ping_var_;
  }
  inline void UserStats::set_udp_ping_var(float value)
  {
    set_has_udp_ping_var();
    udp_ping_var_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_ping_var)
  }

// optional float tcp_ping_avg = 10;
  inline bool UserStats::has_tcp_ping_avg() const
  {
    return (_has_bits_[0] & 0x00000200u) != 0;
  }
  inline void UserStats::set_has_tcp_ping_avg()
  {
    _has_bits_[0] |= 0x00000200u;
  }
  inline void UserStats::clear_has_tcp_ping_avg()
  {
    _has_bits_[0] &= ~0x00000200u;
  }
  inline void UserStats::clear_tcp_ping_avg()
  {
    tcp_ping_avg_ = 0;
    clear_has_tcp_ping_avg();
  }
  inline float UserStats::tcp_ping_avg() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_ping_avg)
    return tcp_ping_avg_;
  }
  inline void UserStats::set_tcp_ping_avg(float value)
  {
    set_has_tcp_ping_avg();
    tcp_ping_avg_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_ping_avg)
  }

// optional float tcp_ping_var = 11;
  inline bool UserStats::has_tcp_ping_var() const
  {
    return (_has_bits_[0] & 0x00000400u) != 0;
  }
  inline void UserStats::set_has_tcp_ping_var()
  {
    _has_bits_[0] |= 0x00000400u;
  }
  inline void UserStats::clear_has_tcp_ping_var()
  {
    _has_bits_[0] &= ~0x00000400u;
  }
  inline void UserStats::clear_tcp_ping_var()
  {
    tcp_ping_var_ = 0;
    clear_has_tcp_ping_var();
  }
  inline float UserStats::tcp_ping_var() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_ping_var)
    return tcp_ping_var_;
  }
  inline void UserStats::set_tcp_ping_var(float value)
  {
    set_has_tcp_ping_var();
    tcp_ping_var_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_ping_var)
  }

// optional .MumbleProto.Version version = 12;
  inline bool UserStats::has_version() const
  {
    return (_has_bits_[0] & 0x00000800u) != 0;
  }
  inline void UserStats::set_has_version()
  {
    _has_bits_[0] |= 0x00000800u;
  }
  inline void UserStats::clear_has_version()
  {
    _has_bits_[0] &= ~0x00000800u;
  }
  inline void UserStats::clear_version()
  {
    if (version_ != NULL) version_->::MumbleProto::Version::Clear();
    clear_has_version();
  }
  inline const ::MumbleProto::Version& UserStats::version() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.version)
    return version_ != NULL ? *version_ : *default_instance_->version_;
  }
  inline ::MumbleProto::Version* UserStats::mutable_version()
  {
    set_has_version();
    if (version_ == NULL) version_ = new ::MumbleProto::Version;
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.version)
    return version_;
  }
  inline ::MumbleProto::Version* UserStats::release_version()
  {
    clear_has_version();
    ::MumbleProto::Version* temp = version_;
    version_ = NULL;
    return temp;
  }
  inline void UserStats::set_allocated_version(::MumbleProto::Version* version)
  {
    delete version_;
    version_ = version;
    if (version)
      {
        set_has_version();
      }
    else
      {
        clear_has_version();
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.version)
  }

// repeated int32 celt_versions = 13;
  inline int UserStats::celt_versions_size() const
  {
    return celt_versions_.size();
  }
  inline void UserStats::clear_celt_versions()
  {
    celt_versions_.Clear();
  }
  inline ::google::protobuf::int32 UserStats::celt_versions(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.celt_versions)
    return celt_versions_.Get(index);
  }
  inline void UserStats::set_celt_versions(int index,
      ::google::protobuf::int32 value)
  {
    celt_versions_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.celt_versions)
  }
  inline void UserStats::add_celt_versions(::google::protobuf::int32 value)
  {
    celt_versions_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.UserStats.celt_versions)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
  UserStats::celt_versions() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.UserStats.celt_versions)
    return celt_versions_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
  UserStats::mutable_celt_versions()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserStats.celt_versions)
    return &celt_versions_;
  }

// optional bytes address = 14;
  inline bool UserStats::has_address() const
  {
    return (_has_bits_[0] & 0x00002000u) != 0;
  }
  inline void UserStats::set_has_address()
  {
    _has_bits_[0] |= 0x00002000u;
  }
  inline void UserStats::clear_has_address()
  {
    _has_bits_[0] &= ~0x00002000u;
  }
  inline void UserStats::clear_address()
  {
    if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_->clear();
      }
    clear_has_address();
  }
  inline const ::std::string& UserStats::address() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.address)
    return *address_;
  }
  inline void UserStats::set_address(const ::std::string& value)
  {
    set_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_ = new ::std::string;
      }
    address_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.address)
  }
  inline void UserStats::set_address(const char* value)
  {
    set_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_ = new ::std::string;
      }
    address_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.UserStats.address)
  }
  inline void UserStats::set_address(const void* value, size_t size)
  {
    set_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_ = new ::std::string;
      }
    address_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserStats.address)
  }
  inline ::std::string* UserStats::mutable_address()
  {
    set_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        address_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.address)
    return address_;
  }
  inline ::std::string* UserStats::release_address()
  {
    clear_has_address();
    if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = address_;
        address_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void UserStats::set_allocated_address(::std::string* address)
  {
    if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete address_;
      }
    if (address)
      {
        set_has_address();
        address_ = address;
      }
    else
      {
        clear_has_address();
        address_ = const_cast< ::std::string*>
                   (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.address)
  }

// optional uint32 bandwidth = 15;
  inline bool UserStats::has_bandwidth() const
  {
    return (_has_bits_[0] & 0x00004000u) != 0;
  }
  inline void UserStats::set_has_bandwidth()
  {
    _has_bits_[0] |= 0x00004000u;
  }
  inline void UserStats::clear_has_bandwidth()
  {
    _has_bits_[0] &= ~0x00004000u;
  }
  inline void UserStats::clear_bandwidth()
  {
    bandwidth_ = 0u;
    clear_has_bandwidth();
  }
  inline ::google::protobuf::uint32 UserStats::bandwidth() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.bandwidth)
    return bandwidth_;
  }
  inline void UserStats::set_bandwidth(::google::protobuf::uint32 value)
  {
    set_has_bandwidth();
    bandwidth_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.bandwidth)
  }

// optional uint32 onlinesecs = 16;
  inline bool UserStats::has_onlinesecs() const
  {
    return (_has_bits_[0] & 0x00008000u) != 0;
  }
  inline void UserStats::set_has_onlinesecs()
  {
    _has_bits_[0] |= 0x00008000u;
  }
  inline void UserStats::clear_has_onlinesecs()
  {
    _has_bits_[0] &= ~0x00008000u;
  }
  inline void UserStats::clear_onlinesecs()
  {
    onlinesecs_ = 0u;
    clear_has_onlinesecs();
  }
  inline ::google::protobuf::uint32 UserStats::onlinesecs() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.onlinesecs)
    return onlinesecs_;
  }
  inline void UserStats::set_onlinesecs(::google::protobuf::uint32 value)
  {
    set_has_onlinesecs();
    onlinesecs_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.onlinesecs)
  }

// optional uint32 idlesecs = 17;
  inline bool UserStats::has_idlesecs() const
  {
    return (_has_bits_[0] & 0x00010000u) != 0;
  }
  inline void UserStats::set_has_idlesecs()
  {
    _has_bits_[0] |= 0x00010000u;
  }
  inline void UserStats::clear_has_idlesecs()
  {
    _has_bits_[0] &= ~0x00010000u;
  }
  inline void UserStats::clear_idlesecs()
  {
    idlesecs_ = 0u;
    clear_has_idlesecs();
  }
  inline ::google::protobuf::uint32 UserStats::idlesecs() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.idlesecs)
    return idlesecs_;
  }
  inline void UserStats::set_idlesecs(::google::protobuf::uint32 value)
  {
    set_has_idlesecs();
    idlesecs_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.idlesecs)
  }

// optional bool strong_certificate = 18 [default = false];
  inline bool UserStats::has_strong_certificate() const
  {
    return (_has_bits_[0] & 0x00020000u) != 0;
  }
  inline void UserStats::set_has_strong_certificate()
  {
    _has_bits_[0] |= 0x00020000u;
  }
  inline void UserStats::clear_has_strong_certificate()
  {
    _has_bits_[0] &= ~0x00020000u;
  }
  inline void UserStats::clear_strong_certificate()
  {
    strong_certificate_ = false;
    clear_has_strong_certificate();
  }
  inline bool UserStats::strong_certificate() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.strong_certificate)
    return strong_certificate_;
  }
  inline void UserStats::set_strong_certificate(bool value)
  {
    set_has_strong_certificate();
    strong_certificate_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.strong_certificate)
  }

// optional bool opus = 19 [default = false];
  inline bool UserStats::has_opus() const
  {
    return (_has_bits_[0] & 0x00040000u) != 0;
  }
  inline void UserStats::set_has_opus()
  {
    _has_bits_[0] |= 0x00040000u;
  }
  inline void UserStats::clear_has_opus()
  {
    _has_bits_[0] &= ~0x00040000u;
  }
  inline void UserStats::clear_opus()
  {
    opus_ = false;
    clear_has_opus();
  }
  inline bool UserStats::opus() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.UserStats.opus)
    return opus_;
  }
  inline void UserStats::set_opus(bool value)
  {
    set_has_opus();
    opus_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.UserStats.opus)
  }

// -------------------------------------------------------------------

// RequestBlob

// repeated uint32 session_texture = 1;
  inline int RequestBlob::session_texture_size() const
  {
    return session_texture_.size();
  }
  inline void RequestBlob::clear_session_texture()
  {
    session_texture_.Clear();
  }
  inline ::google::protobuf::uint32 RequestBlob::session_texture(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.session_texture)
    return session_texture_.Get(index);
  }
  inline void RequestBlob::set_session_texture(int index,
      ::google::protobuf::uint32 value)
  {
    session_texture_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.session_texture)
  }
  inline void RequestBlob::add_session_texture(::google::protobuf::uint32 value)
  {
    session_texture_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.session_texture)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  RequestBlob::session_texture() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.session_texture)
    return session_texture_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  RequestBlob::mutable_session_texture()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.session_texture)
    return &session_texture_;
  }

// repeated uint32 session_comment = 2;
  inline int RequestBlob::session_comment_size() const
  {
    return session_comment_.size();
  }
  inline void RequestBlob::clear_session_comment()
  {
    session_comment_.Clear();
  }
  inline ::google::protobuf::uint32 RequestBlob::session_comment(int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.session_comment)
    return session_comment_.Get(index);
  }
  inline void RequestBlob::set_session_comment(int index,
      ::google::protobuf::uint32 value)
  {
    session_comment_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.session_comment)
  }
  inline void RequestBlob::add_session_comment(::google::protobuf::uint32 value)
  {
    session_comment_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.session_comment)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  RequestBlob::session_comment() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.session_comment)
    return session_comment_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  RequestBlob::mutable_session_comment()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.session_comment)
    return &session_comment_;
  }

// repeated uint32 channel_description = 3;
  inline int RequestBlob::channel_description_size() const
  {
    return channel_description_.size();
  }
  inline void RequestBlob::clear_channel_description()
  {
    channel_description_.Clear();
  }
  inline ::google::protobuf::uint32 RequestBlob::channel_description(
    int index) const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.channel_description)
    return channel_description_.Get(index);
  }
  inline void RequestBlob::set_channel_description(int index,
      ::google::protobuf::uint32 value)
  {
    channel_description_.Set(index, value);
    // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.channel_description)
  }
  inline void RequestBlob::add_channel_description(::google::protobuf::uint32
      value)
  {
    channel_description_.Add(value);
    // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.channel_description)
  }
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
  RequestBlob::channel_description() const
  {
    // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.channel_description)
    return channel_description_;
  }
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
  RequestBlob::mutable_channel_description()
  {
    // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.channel_description)
    return &channel_description_;
  }

// -------------------------------------------------------------------

// ServerConfig

// optional uint32 max_bandwidth = 1;
  inline bool ServerConfig::has_max_bandwidth() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void ServerConfig::set_has_max_bandwidth()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void ServerConfig::clear_has_max_bandwidth()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void ServerConfig::clear_max_bandwidth()
  {
    max_bandwidth_ = 0u;
    clear_has_max_bandwidth();
  }
  inline ::google::protobuf::uint32 ServerConfig::max_bandwidth() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.max_bandwidth)
    return max_bandwidth_;
  }
  inline void ServerConfig::set_max_bandwidth(::google::protobuf::uint32 value)
  {
    set_has_max_bandwidth();
    max_bandwidth_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.max_bandwidth)
  }

// optional string welcome_text = 2;
  inline bool ServerConfig::has_welcome_text() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void ServerConfig::set_has_welcome_text()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void ServerConfig::clear_has_welcome_text()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void ServerConfig::clear_welcome_text()
  {
    if (welcome_text_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_->clear();
      }
    clear_has_welcome_text();
  }
  inline const ::std::string& ServerConfig::welcome_text() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.welcome_text)
    return *welcome_text_;
  }
  inline void ServerConfig::set_welcome_text(const ::std::string& value)
  {
    set_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_ = new ::std::string;
      }
    welcome_text_->assign(value);
    // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.welcome_text)
  }
  inline void ServerConfig::set_welcome_text(const char* value)
  {
    set_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_ = new ::std::string;
      }
    welcome_text_->assign(value);
    // @@protoc_insertion_point(field_set_char:MumbleProto.ServerConfig.welcome_text)
  }
  inline void ServerConfig::set_welcome_text(const char* value, size_t size)
  {
    set_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_ = new ::std::string;
      }
    welcome_text_->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:MumbleProto.ServerConfig.welcome_text)
  }
  inline ::std::string* ServerConfig::mutable_welcome_text()
  {
    set_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        welcome_text_ = new ::std::string;
      }
    // @@protoc_insertion_point(field_mutable:MumbleProto.ServerConfig.welcome_text)
    return welcome_text_;
  }
  inline ::std::string* ServerConfig::release_welcome_text()
  {
    clear_has_welcome_text();
    if (welcome_text_ ==
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        return NULL;
      }
    else
      {
        ::std::string* temp = welcome_text_;
        welcome_text_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        return temp;
      }
  }
  inline void ServerConfig::set_allocated_welcome_text(::std::string*
      welcome_text)
  {
    if (welcome_text_ !=
        &::google::protobuf::internal::GetEmptyStringAlreadyInited())
      {
        delete welcome_text_;
      }
    if (welcome_text)
      {
        set_has_welcome_text();
        welcome_text_ = welcome_text;
      }
    else
      {
        clear_has_welcome_text();
        welcome_text_ = const_cast< ::std::string*>
                        (&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      }
    // @@protoc_insertion_point(field_set_allocated:MumbleProto.ServerConfig.welcome_text)
  }

// optional bool allow_html = 3;
  inline bool ServerConfig::has_allow_html() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void ServerConfig::set_has_allow_html()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void ServerConfig::clear_has_allow_html()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void ServerConfig::clear_allow_html()
  {
    allow_html_ = false;
    clear_has_allow_html();
  }
  inline bool ServerConfig::allow_html() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.allow_html)
    return allow_html_;
  }
  inline void ServerConfig::set_allow_html(bool value)
  {
    set_has_allow_html();
    allow_html_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.allow_html)
  }

// optional uint32 message_length = 4;
  inline bool ServerConfig::has_message_length() const
  {
    return (_has_bits_[0] & 0x00000008u) != 0;
  }
  inline void ServerConfig::set_has_message_length()
  {
    _has_bits_[0] |= 0x00000008u;
  }
  inline void ServerConfig::clear_has_message_length()
  {
    _has_bits_[0] &= ~0x00000008u;
  }
  inline void ServerConfig::clear_message_length()
  {
    message_length_ = 0u;
    clear_has_message_length();
  }
  inline ::google::protobuf::uint32 ServerConfig::message_length() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.message_length)
    return message_length_;
  }
  inline void ServerConfig::set_message_length(::google::protobuf::uint32 value)
  {
    set_has_message_length();
    message_length_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.message_length)
  }

// optional uint32 image_message_length = 5;
  inline bool ServerConfig::has_image_message_length() const
  {
    return (_has_bits_[0] & 0x00000010u) != 0;
  }
  inline void ServerConfig::set_has_image_message_length()
  {
    _has_bits_[0] |= 0x00000010u;
  }
  inline void ServerConfig::clear_has_image_message_length()
  {
    _has_bits_[0] &= ~0x00000010u;
  }
  inline void ServerConfig::clear_image_message_length()
  {
    image_message_length_ = 0u;
    clear_has_image_message_length();
  }
  inline ::google::protobuf::uint32 ServerConfig::image_message_length() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.image_message_length)
    return image_message_length_;
  }
  inline void ServerConfig::set_image_message_length(::google::protobuf::uint32
      value)
  {
    set_has_image_message_length();
    image_message_length_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.image_message_length)
  }

// optional uint32 max_users = 6;
  inline bool ServerConfig::has_max_users() const
  {
    return (_has_bits_[0] & 0x00000020u) != 0;
  }
  inline void ServerConfig::set_has_max_users()
  {
    _has_bits_[0] |= 0x00000020u;
  }
  inline void ServerConfig::clear_has_max_users()
  {
    _has_bits_[0] &= ~0x00000020u;
  }
  inline void ServerConfig::clear_max_users()
  {
    max_users_ = 0u;
    clear_has_max_users();
  }
  inline ::google::protobuf::uint32 ServerConfig::max_users() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.max_users)
    return max_users_;
  }
  inline void ServerConfig::set_max_users(::google::protobuf::uint32 value)
  {
    set_has_max_users();
    max_users_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.max_users)
  }

// -------------------------------------------------------------------

// SuggestConfig

// optional uint32 version = 1;
  inline bool SuggestConfig::has_version() const
  {
    return (_has_bits_[0] & 0x00000001u) != 0;
  }
  inline void SuggestConfig::set_has_version()
  {
    _has_bits_[0] |= 0x00000001u;
  }
  inline void SuggestConfig::clear_has_version()
  {
    _has_bits_[0] &= ~0x00000001u;
  }
  inline void SuggestConfig::clear_version()
  {
    version_ = 0u;
    clear_has_version();
  }
  inline ::google::protobuf::uint32 SuggestConfig::version() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.version)
    return version_;
  }
  inline void SuggestConfig::set_version(::google::protobuf::uint32 value)
  {
    set_has_version();
    version_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.version)
  }

// optional bool positional = 2;
  inline bool SuggestConfig::has_positional() const
  {
    return (_has_bits_[0] & 0x00000002u) != 0;
  }
  inline void SuggestConfig::set_has_positional()
  {
    _has_bits_[0] |= 0x00000002u;
  }
  inline void SuggestConfig::clear_has_positional()
  {
    _has_bits_[0] &= ~0x00000002u;
  }
  inline void SuggestConfig::clear_positional()
  {
    positional_ = false;
    clear_has_positional();
  }
  inline bool SuggestConfig::positional() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.positional)
    return positional_;
  }
  inline void SuggestConfig::set_positional(bool value)
  {
    set_has_positional();
    positional_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.positional)
  }

// optional bool push_to_talk = 3;
  inline bool SuggestConfig::has_push_to_talk() const
  {
    return (_has_bits_[0] & 0x00000004u) != 0;
  }
  inline void SuggestConfig::set_has_push_to_talk()
  {
    _has_bits_[0] |= 0x00000004u;
  }
  inline void SuggestConfig::clear_has_push_to_talk()
  {
    _has_bits_[0] &= ~0x00000004u;
  }
  inline void SuggestConfig::clear_push_to_talk()
  {
    push_to_talk_ = false;
    clear_has_push_to_talk();
  }
  inline bool SuggestConfig::push_to_talk() const
  {
    // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.push_to_talk)
    return push_to_talk_;
  }
  inline void SuggestConfig::set_push_to_talk(bool value)
  {
    set_has_push_to_talk();
    push_to_talk_ = value;
    // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.push_to_talk)
  }


// @@protoc_insertion_point(namespace_scope)

}  // namespace MumbleProto

#ifndef SWIG
namespace google
{
  namespace protobuf
  {

    template <> struct
      is_proto_enum< ::MumbleProto::Reject_RejectType> : ::google::protobuf::internal::true_type {};
    template <>
    inline const EnumDescriptor*
    GetEnumDescriptor< ::MumbleProto::Reject_RejectType>()
    {
      return ::MumbleProto::Reject_RejectType_descriptor();
    }
    template <> struct
      is_proto_enum< ::MumbleProto::PermissionDenied_DenyType> : ::google::protobuf::internal::true_type {};
    template <>
    inline const EnumDescriptor*
    GetEnumDescriptor< ::MumbleProto::PermissionDenied_DenyType>()
    {
      return ::MumbleProto::PermissionDenied_DenyType_descriptor();
    }
    template <> struct
      is_proto_enum< ::MumbleProto::ContextActionModify_Context> : ::google::protobuf::internal::true_type {};
    template <>
    inline const EnumDescriptor*
    GetEnumDescriptor< ::MumbleProto::ContextActionModify_Context>()
    {
      return ::MumbleProto::ContextActionModify_Context_descriptor();
    }
    template <> struct
      is_proto_enum< ::MumbleProto::ContextActionModify_Operation> : ::google::protobuf::internal::true_type {};
    template <>
    inline const EnumDescriptor*
    GetEnumDescriptor< ::MumbleProto::ContextActionModify_Operation>()
    {
      return ::MumbleProto::ContextActionModify_Operation_descriptor();
    }

  }  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Mumble_2eproto__INCLUDED
